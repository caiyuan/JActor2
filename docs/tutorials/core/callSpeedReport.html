<html>
<head> <title>Call Methods per Second</title>
</head>
<body>
<p>
<a href="https://github.com/laforge49/JActor2#readme">JActor2</a> &gt; <a href="../../index.html">Docs</a> &gt; <a href="../index.html">Tutorials</a> &gt; <a href="index.html">Core</a> &gt; CallSpeedReport
</p>
<h1>CallSpeedReport - Call Methods per Second</h1>
<p>
The 
<a href="../../api/core/org/agilewiki/jactor2/core/requests/SOp.html#call--">call</a>
method is quite slow as it blocks the originating thread, 
allocates a thread to the target reactor,
creates a message and adds it to the concurrent linked queue of that reactor.
The message must then be dequeued and evaluated on the new thread.
The message is then updated with a response and the originating thread is woken up.
Fortunately the call method is not used very often!
</p>
<p>
<a href="java7/CallSpeedReport.java">CallSpeedReport</a>
is a small program that will tell us just how fast the call method is.
</p>
<pre>
import org.agilewiki.jactor2.core.impl.Plant;

public class CallSpeedReport {
    public static void main(final String[] _args) throws Exception {
        final long count = 1000000L;
        Plant plant = new Plant();
        try {
            Ponger ponger = new Ponger();
            SOp&lt;Long&gt; pingSOp = ponger.pingSOp();
            final long before = System.nanoTime();
            long i = 0L;
            while (i &lt; count) {
                i += 1;
                long j = pingSOp.call();
            }
            final long after = System.nanoTime();
            final long duration = after - before;
            SpeedReport.print("Call Timings", duration, count);
        } finally {
            plant.close();
        }
    }
}
</pre>
<p>
This benchmark is pretty straight forward. We call the ping request in a loop and then use 
<a href="java7/SpeedReport.java">SpeedReport</a> to calculate and print the results.
</p>
<pre>
public class SpeedReport {
    public static void print(
            final String _heading, 
            final long _ns, 
            final long _count) {
        System.out.println("");
        System.out.println(_heading);
        System.out.println("Test duration in nanoseconds: " + _ns);
        System.out.println("Number of exchanges: " + _count);
        if (_ns &gt; 0) {
            System.out.println("Exchanges per second: " + (1000000000L * _count / _ns));
            System.out.println("Latency in seconds: " + (_ns / (1000000000.0 * _count)));
        }
    }
}

Output:

Call Timings
Test duration in nanoseconds: 7731381822
Number of exchanges: 1000000
Exchanges per second: 129342
Latency in seconds: 7.731381822E-6
</pre>
<p>
By themselves the numbers are pretty meaningless. These test results were done on a system with both a fast CPU and
fast RAM.
But we can compare these numbers to other methods to gauge relative performance.
</p>
</body>
</html>
