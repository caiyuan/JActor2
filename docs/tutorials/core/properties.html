<html>
<body>
<p>
<a href="https://github.com/laforge49/JActor2#readme">JActor2</a> &gt; <a href="../../index.html">Docs</a> &gt; <a href="../index.html">Tutorials</a> &gt; <a href="index.html">Core</a> &gt; Properties
</p>
<h1>Properties - Easy Transactions</h1>
<p>
The <a href="../../api/org/agilewiki/jactor2/core/blades/transactions/properties/package-summary.html">properties</a>
package implements a transactional properties processor with an immutable properties map, and supports hooks for both
validation and change notifications. It is easy to use, fully extensible and lock free. But the question is, why?
</p>
<p>
The answer is, to bring a bit of order to the chaos of a multi-threading framework. You can easily ensure that 
a blade gets notified whenever a property of interest is changed. Or that a property is only assigned values
of a particular type. Or that there are no race conditions when a change to a property depends on its previous 
value.
</p>
<p>
The <a href="Properties.java">Properties</a> program covers some of the basics of using the 
<a href="../../api/org/agilewiki/jactor2/core/blades/transactions/properties/PropertiesProcessor.html">PropertiesProcessor</a>
class and, in particular, provides an example of a custom transaction.
</p>
<pre>
import org.agilewiki.jactor2.core.blades.transactions.properties.PropertiesChangeManager;
import org.agilewiki.jactor2.core.blades.transactions.properties.PropertiesProcessor;
import org.agilewiki.jactor2.core.blades.transactions.properties.PropertiesTransactionAReq;
import org.agilewiki.jactor2.core.facilities.BasicPlant;
import org.agilewiki.jactor2.core.facilities.Plant;
import org.agilewiki.jactor2.core.reactors.IsolationReactor;
import org.agilewiki.jactor2.core.util.immutable.ImmutableProperties;

import java.util.*;

public class Properties {
    public static void main(final String[] _args) throws Exception {
        final BasicPlant plant = new Plant();
        try {
            PropertiesProcessor propertiesProcessor = 
                new PropertiesProcessor(new IsolationReactor());
            propertiesProcessor.putAReq("a", 1).call();
            System.out.println(propertiesProcessor.getImmutableState());
            new IncAReq(propertiesProcessor, "a", 41).call();
            System.out.println(propertiesProcessor.getImmutableState());
        } finally {
            plant.close();
        }
    }
}

Output:

{a=1}
{a=42}
</pre>
<p>
The above program creates a PropertiesProcessor instance, calls putAReq to set "a" to 1 and prints the
immutable properties.
Then it calls IncAReq to add 41 to property "a" and prints the new verion of the immutable properties.
IncAReq is a custom transaction:
</p>
<pre>
class IncAReq extends PropertiesTransactionAReq {
    final String name;
    final int increment;

    public IncAReq(final PropertiesProcessor _propertiesProcessor,
                   final String _name,
                   final int _increment) {
        super(_propertiesProcessor.commonReactor, _propertiesProcessor);
        name = _name;
        increment = _increment;
    }

    {@literal @}Override
    protected void update(final PropertiesChangeManager _contentManager) throws Exception {
        int oldValue = (Integer) _contentManager.getImmutableProperties().get(name);
        int newValue = oldValue + increment;
        _contentManager.put(name, newValue);
    }
}
</pre>
<p>
The update method applies any desired changes to the 
<a href="../../api/org/agilewiki/jactor2/core/blades/transactions/properties/PropertiesChangeManager.html">PropertiesChangeManager</a>.
Once the changes have been validated, the immutable properties are updated and notifications are passed
to all interested parties.
</p>
<p>
In this particular example, the update method is thread safe. So the reactor passed as the first argument
in the 
<a href="../../api/org/agilewiki/jactor2/core/blades/transactions/properties/PropertiesTransactionAReq.html">PropertiesTransactionAReq</a> 
constructor is just the common reactor of the PropertiesProcessor.
But if the update method is not thread safe and must be executed under a particular reactor, then
simply pass that reactor to the PropertiesTransactionAReq constructor.
</p>
</body>
</html>
