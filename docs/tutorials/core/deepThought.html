<html>
<body>
<p>
<a href="https://github.com/laforge49/JActor2#readme">JActor2</a> &gt; <a href="../../index.html">Docs</a> &gt; <a href="../index.html">Tutorials</a> &gt; <a href="index.html">Core</a> &gt; DeepThought
</p>
<h1>DeepThought - Multiple Exchanges</h1>
<p>
More often than not, a blade will need to exchange messages with more multiple blades on other reactors.
The <a href="DeepThought.java">DeepThought</a> blade does just that. First it uses the Delay blade to pause for 4 seconds.
Then it fetches the facility printer blade before printing a message.
</p>
<pre>
import org.agilewiki.jactor2.core.blades.NonBlockingBladeBase;
import org.agilewiki.jactor2.core.blades.misc.Delay;
import org.agilewiki.jactor2.core.blades.misc.Printer;
import org.agilewiki.jactor2.core.facilities.BasicPlant;
import org.agilewiki.jactor2.core.facilities.Plant;
import org.agilewiki.jactor2.core.messages.AsyncRequest;
import org.agilewiki.jactor2.core.messages.AsyncResponseProcessor;
import org.agilewiki.jactor2.core.messages.SyncRequest;
import org.agilewiki.jactor2.core.reactors.NonBlockingReactor;

public class DeepThought extends NonBlockingBladeBase {
    public DeepThought(final NonBlockingReactor _reactor) throws Exception {
        initialize(_reactor);
    }
    
    public AsyncRequest&lt;Void&gt; printAnswerAReq() {
        return new AsyncBladeRequest&lt;Void&gt;() {
            final AsyncResponseProcessor&lt;Void&gt; dis = this;

            final AsyncResponseProcessor&lt;Printer&gt; stdoutResponseProcessor =
                    new AsyncResponseProcessor&lt;Printer&gt;() {
                @Override
                public void processAsyncResponse(final Printer _printer) throws Exception {
                    SyncRequest&lt;Void&gt; printRequest = _printer.printlnSReq("I am sorry, but did you say something?");
                    send(printRequest, dis);
                }
            };

            final AsyncResponseProcessor&lt;Void&gt; sleepResponseProcessor =
                    new AsyncResponseProcessor&lt;Void&gt;() {
                @Override
                public void processAsyncResponse(final Void _response) throws Exception {
                    AsyncRequest&lt;Printer&gt; stdoutRequest = Printer.stdoutAReq();
                    send(stdoutRequest, stdoutResponseProcessor);
                }
            };

            @Override
            public void processAsyncRequest() throws Exception {
                Reactor myReactor = getReactor();
                Delay delay = new Delay();
                SyncRequest&lt;Void&gt; sleepSReq = delay.sleepSReq(4000);
                send(sleepSReq, sleepResponseProcessor);
            }
        };
    }
    
    public static void main(final String[] _args) throws Exception {
        BasicPlant plant = new Plant();
        try {
            DeepThought deepThought = new DeepThought(new NonBlockingReactor(plant));
            AsyncRequest&lt;Void&gt; printAnswerAReq = deepThought.printAnswerAReq();
            printAnswerAReq.call();
        } finally {
            plant.close();
        }
    }
}
</pre>
<h3>
Chaining
</h3>
<p>
This is how multiple exchanges can be chained together.
</p>
<pre>
            @Override
            public void processAsyncRequest() throws Exception {
                Delay delay = new Delay();
                SyncRequest&lt;Void&gt; sleepSReq = delay.sleepSReq(4000);
                send(sleepSReq, sleepResponseProcessor);
            }
</pre>
<p>
When the response from the sleep request is processed,
the stdout request is sent to fetch the facility printer.
</p>
<pre>
            final AsyncResponseProcessor&lt;Void&gt; sleepResponseProcessor =
                    new AsyncResponseProcessor&lt;Void&gt;() {
                @Override
                public void processAsyncResponse(final Void _response) throws Exception {
                    SyncRequest&lt;Printer&gt; stdoutRequest = Printer.stdoutSReq();
                    send(stdoutRequest, stdoutResponseProcessor);
                }
            };
</pre>
<p>
On receipt of the printer, a message is printed.
</p>
<pre>
            final AsyncResponseProcessor&lt;Printer&gt; stdoutResponseProcessor =
                    new AsyncResponseProcessor&lt;Printer&gt;() {
                @Override
                public void processAsyncResponse(final Printer _printer) throws Exception {
                    SyncRequest&lt;Void&gt; printRequest = _printer.printlnSReq("I am sorry, but did you say something?");
                    send(printRequest, dis);
                }
            };
</pre>
<p>
By this means, any number of exchanges can be performed, one after another.
</p>
</body>
</html>
