<html>
<body>
<p>
<a href="https://github.com/laforge49/JActor2#readme">JActor2</a> &gt; <a href="../../index.html">Docs</a> &gt; <a href="../index.html">Tutorials</a> &gt; <a href="index.html">Core</a> &gt; Recovery
</p>
<h1>Recovery - When failures occur</h1>
<p>
In <a href="gettingStarted.html">Getting Started</a> we saw how we could change the plant configuration using a system property
to specify a subclass of
<a href="../../api/org/agilewiki/jactor2/core/plant/PlantConfiguration.html">PlantConfiguration</a>.
Alternatively, you can use a
<a href="../../api/org/agilewiki/jactor2/core/plant/Plant.html#Plant-org.agilewiki.jactor2.core.plant.PlantConfiguration-">Plant constructor</a>
to specify the desired subclass of PlantConfiguration.
</p>
<p>
The <a href="../../api/org/agilewiki/jactor2/core/plant/Recovery.html">Recovery</a> class
is included in PlantConfiguration. Recovery defines both failure detection and recovery.
Changing the Recovery class is done by overriding the 
<a href="../../api/org/agilewiki/jactor2/core/plant/PlantConfiguration.html#createRecovery--">createRecovery</a> method
in a subclass of PlantConfiguration.
</p>
When the
<a href="../../api/org/agilewiki/jactor2/core/plant/Plant.html">Plant</a> singleton is created,
it creates a reactor for internal use and assigns the Recovery object found in its PlantConfiguration using the
<a href="../../api/org/agilewiki/jactor2/core/reactors/Reactor.html#setRecovery-org.agilewiki.jactor2.core.plant.Recovery-">setRecovery</a>
method. When subsequent reactors are created, they are assigned the same recovery object as their parent reactor--which is,
by default, the internal reactor of the plant.
<p>
Failures may occur when a reactor processes a request or response message. Three types of failure are handled by Recovery: 
message timeout, hung thread and hung asynchronous request. Which reactor is used to handle a failure is determined by the reactor 
processing the message that caused the failure.
</p>
<h2>Message Timeouts</h2>
<p>
When there are millions of messages processed each second, adding a timer to each one can slow things down considerably.
So instead of timing each message, the reactor tracks when processing began on each message and the reactors are polled
to see if any reactor has been processing the same message for too long. The Recovery method
<a href="../../api/org/agilewiki/jactor2/core/plant/Recovery.html#getReactorPollMillis--">getReactorPollMillis</a>
is used to determine how often the reactors are to be polled. The default value is 500 milliseconds.
</p>
<p>
The Recovery method
<a href="../../api/org/agilewiki/jactor2/core/plant/Recovery.html#getMessageTimeoutMillis-org.agilewiki.jactor2.core.impl.ReactorImpl-">getMessageTimeoutMillis</a>
is used to determine how long a message can be processed before being timed out. The default value is
300,000 milliseconds for blocking reactors and 1,000 milliseconds for all other types of reactors.
</p>
<p>
Once a message has timed out, then the Recovery method
<a href="../../api/org/agilewiki/jactor2/core/plant/Recovery.html#onMessageTimeout-org.agilewiki.jactor2.core.impl.ReactorImpl-">onMessageTimeout</a>
handles the recovery. The default action is to close the Reactor, which results in an interrupt being passed to the thread processing the message. 
The application then has a limited
time to detect and throw an InterruptedException. How long it has is determined by the Recovery method
<a href="../../api/org/agilewiki/jactor2/core/plant/Recovery.html#getThreadInterruptMillis-org.agilewiki.jactor2.core.impl.ReactorImpl-">getThreadInterruptMillis</a>.
The default value is 1,000 milliseconds.
</p>
<p>
If the application logic throws the InterruptedException in time, then the Reactor is successfully closed and all incomplete request are given
a ServiceClosedException.
But if the application logic does not throw an InterruptedException
(or complete the message processing) in time, then the thread is considered hung--which is a far more serious issue.
</p>
<p>
The <a href="java7/Hanger.java">Hanger</a> class is used to test message timeouts.
It has two synchronous requests, sleeper and looper.
The sleeper requests causes a message timeout but uses Thread.sleep which responds to a thread interrupt by throwing an InterruptedException.
In contrast, the looper request does not check to see if the thread has received an interrupt.
</p>
<pre>
import org.agilewiki.jactor2.core.blades.NonBlockingBladeBase;
import org.agilewiki.jactor2.core.reactors.NonBlockingReactor;
import org.agilewiki.jactor2.core.requests.SyncRequest;

class Hanger extends NonBlockingBladeBase {
    Hanger() throws Exception {
        super(new NonBlockingReactor());
    }

    SyncRequest&lt;Void&gt; looperSReq() {
        return new SyncBladeRequest&lt;Void&gt;() {
            @Override
            public Void processSyncRequest() throws Exception {
                while (true) {}
            }
        };
    }

    SyncRequest&lt;Void&gt; sleeperSReq() {
        return new SyncBladeRequest&lt;Void&gt;() {
            @Override
            public Void processSyncRequest() throws Exception {
                try {
                    Thread.sleep(Long.MAX_VALUE);
                } catch (InterruptedException ie) {
                    throw ie;
                }
                return null;
            }
        };
    }
}

    Output:
    
[pool-1-thread-1] ERROR org.agilewiki.jactor2.core.reactors.Reactor - message ti
meout -> reactor close
[Thread-0] WARN org.agilewiki.jactor2.core.reactors.Reactor - message interrupte
d on close message=Hanger$2, isClosed=false, isSignal=false, source=org.agilewik
i.jactor2.core.impl.RequestImplBase$Pender, target=org.agilewiki.jactor2.core.re
actors.NonBlockingReactor, this=org.agilewiki.jactor2.core.impl.SyncRequestImpl@
28741fab
Exception in thread "main" org.agilewiki.jactor2.core.plant.ServiceClosedExcepti
on
        at org.agilewiki.jactor2.core.impl.RequestImplBase.close(RequestImplBase
.java:288)
        at org.agilewiki.jactor2.core.impl.ReactorImpl.close2(ReactorImpl.java:2
02)
        at org.agilewiki.jactor2.core.impl.ReactorImpl.closeAll(ReactorImpl.java
:549)
        at org.agilewiki.jactor2.core.impl.ReactorImpl.close(ReactorImpl.java:16
7)
        at org.agilewiki.jactor2.core.plant.Recovery.onMessageTimeout(Recovery.j
ava:22)
        at org.agilewiki.jactor2.core.impl.ReactorImpl.reactorPoll(ReactorImpl.j
ava:482)
        at org.agilewiki.jactor2.core.impl.ReactorImpl.reactorPoll(ReactorImpl.j
ava:491)
        at org.agilewiki.jactor2.core.impl.PlantImpl$1.run(PlantImpl.java:76)
        at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:51
1)
        at java.util.concurrent.FutureTask.runAndReset(FutureTask.java:308)
        at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.
access$301(ScheduledThreadPoolExecutor.java:180)
        at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.
run(ScheduledThreadPoolExecutor.java:294)
        at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.
java:1142)
        at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor
.java:617)
        at java.lang.Thread.run(Thread.java:744)
</pre>
<h2>Hung Thread</h2>
<h2>Hung Asynchronous Request</h2>
</body>
</html>
