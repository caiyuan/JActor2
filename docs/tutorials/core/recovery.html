<html>
<head>
<title>When failures occur</title>
</head>
<body>
<p>
<a href="https://github.com/laforge49/JActor2#readme">JActor2</a> &gt; <a href="../../index.html">Docs</a> &gt; <a href="../index.html">Tutorials</a> &gt; <a href="index.html">Core</a> &gt; Recovery
</p>
<h1>Recovery - When failures occur</h1>
<p>
In <a href="gettingStarted.html">Getting Started</a> we saw how we could change the plant configuration using a system property
to specify a subclass of
<a href="../../api/coreMt/org/agilewiki/jactor2/core/impl/mtPlant/PlantConfiguration.html">PlantConfiguration</a>.
Alternatively, you can use a
<a href="../../api/coreMt/org/agilewiki/jactor2/core/impl/Plant.html#Plant-org.agilewiki.jactor2.core.plant.PlantConfiguration-">Plant constructor</a>
to specify the desired subclass of PlantConfiguration.
</p>
<p>
PlantConfiguration includes a factory method for <a href="../../api/coreMt/org/agilewiki/jactor2/core/impl/mtPlant/Recovery.html">Recovery</a>. 
Recovery defines both failure detection and recovery.
Changing the Recovery class is done by overriding the 
<a href="../../api/coreMt/org/agilewiki/jactor2/core/impl/mtPlant/PlantConfiguration.html#createRecovery--">createRecovery</a> method
in a subclass of PlantConfiguration.
</p>
When the
<a href="../../api/coreMt/org/agilewiki/jactor2/core/impl/Plant.html">Plant</a> singleton is created,
it creates a reactor for internal use and assigns a Recovery object created by its PlantConfiguration using the
<a href="../../api/coreMt/org/agilewiki/jactor2/core/impl/mtReactors/ReactorMtImpl.html#setRecovery-org.agilewiki.jactor2.core.impl.mtPlant.Recovery-">setRecovery</a>
method. When subsequent reactors are created, they are assigned the same recovery object as their parent reactor--which is,
by default, the internal reactor of the plant.
<p>
Failures may occur when a reactor processes an operation. Three types of failure are handled by Recovery: 
message timeout, hung thread and hung asynchronous request.
</p>
<h2>Message Timeouts</h2>
<p>
When there are millions of messages processed each second, adding a timer to each one can slow things down considerably.
So instead of timing each message, the reactor tracks when processing began on each message and the reactors are polled
to see if any reactor has been processing the same message for too long. The Recovery method
<a href="../../api/coreMt/org/agilewiki/jactor2/core/impl/mtPlant/Recovery.html#getReactorPollMillis--">getReactorPollMillis</a>
is used to determine how often the reactors are to be polled. The default value is 500 milliseconds.
</p>
<p>
The Recovery method
<a href="../../api/coreMt/org/agilewiki/jactor2/core/impl/mtPlant/Recovery.html#getMessageTimeoutMillis-org.agilewiki.jactor2.core.impl.mtReactors.ReactorMtImpl-">getMessageTimeoutMillis</a>
is used to determine how long a message can be processed before being timed out. The default value is
300,000 milliseconds for blocking reactors and 1,000 milliseconds for all other types of reactors.
</p>
<p>
Once a message has timed out, then the Recovery method
<a href="../../api/coreMt/org/agilewiki/jactor2/core/impl/mtPlant/Recovery.html#onMessageTimeout-org.agilewiki.jactor2.core.reactors.impl.ReactorImpl-">onMessageTimeout</a>
handles the recovery. The default action is to close the Reactor, which results in an interrupt being passed to the thread processing the message. 
The application then has a limited
time to detect and throw an InterruptedException. How long it has is determined by the Recovery method
<a href="../../api/coreMt/org/agilewiki/jactor2/core/impl/mtPlant/Recovery.html#getThreadInterruptMillis-org.agilewiki.jactor2.core.reactors.impl.ReactorImpl-">getThreadInterruptMillis</a>.
The default value is 1,000 milliseconds.
</p>
<p>
If the application logic throws the InterruptedException in time, then the Reactor is successfully closed and all incomplete request are given
a ServiceClosedException.
But if the application logic does not throw an InterruptedException
(or complete the message processing) in time, then the thread is considered hung--which is a far more serious issue.
</p>
<p>
The <a href="java7/Hanger.java">Hanger</a> class is used to test message timeouts.
It has two synchronous requests, sleeper and looper.
The sleeper requests causes a message timeout but uses Thread.sleep which responds to a thread interrupt by throwing an InterruptedException.
In contrast, the looper request does not check to see if the thread has received an interrupt.
</p>
<pre>
import org.agilewiki.jactor2.core.blades.NonBlockingBladeBase;
import org.agilewiki.jactor2.core.reactors.NonBlockingReactor;
import org.agilewiki.jactor2.core.requests.SOp;
import org.agilewiki.jactor2.core.requests.impl.RequestImpl;

class Hanger extends NonBlockingBladeBase {
    Hanger() throws Exception {
        super(new NonBlockingReactor());
    }

    SOp&lt;Void&gt; looperSOp() {
        return new SOp&lt;Void&gt;("looper", getReactor()) {
            @Override
            protected Void processSyncOperation(final RequestImpl _requestImpl) throws Exception {
                while (true) {}
            }
        };
    }

    SOp&lt;Void&gt; sleeperSOp() {
        return new SOp&lt;Void&gt;("sleeper", getReactor()) {
            @Override
            protected Void processSyncOperation(final RequestImpl _requestImpl) throws Exception {
                Thread.sleep(Long.MAX_VALUE);
                return null;
            }
        };
    }
}
</pre>
<p>
The <a href="java7/SleeperMessageTimeout.java">SleeperMessageTimeout</a> program
calls the sleeper request to demonstrate the result of a message timeout.
As you can see below, the Hanger's reactor is closed and the result of the call to
sleeper is that a ServiceClosedException is thrown.
</p>
<pre>
import org.agilewiki.jactor2.core.impl.Plant;

public class SleeperMessageTimeout {
    static public void main(final String[] _args) throws Exception {
        final Plant plant = new Plant();
        try {
            Hanger hanger = new Hanger();
            hanger.sleeperSOp().call();
            System.out.println("never gets here");
        } finally {
            plant.close();
        }
    }
}

    Output:
    
[pool-1-thread-2] ERROR org.agilewiki.jactor2.core.reactors.Reactor - message ti
meout -> reactor close
[Thread-1] WARN org.agilewiki.jactor2.core.reactors.Reactor - message interrupte
d on close message=sleeper, isComplete=false, isOneWay=false, source=org.agilewi
ki.jactor2.core.impl.mtRequests.RequestMtImpl$Pender@4f83e6d4, target=org.agilew
iki.jactor2.core.impl.mtReactors.NonBlockingReactorMtImpl@21bf446e, this=org.agi
lewiki.jactor2.core.impl.mtRequests.SyncRequestMtImpl@5ca79114
Exception in thread "main" org.agilewiki.jactor2.core.reactors.ReactorClosedExce
ption
        at org.agilewiki.jactor2.core.impl.mtRequests.RequestMtImpl.close(Reques
tMtImpl.java:345)
        at org.agilewiki.jactor2.core.impl.mtReactors.ReactorMtImpl.fail(Reactor
MtImpl.java:304)
        at org.agilewiki.jactor2.core.impl.mtPlant.Recovery.onMessageTimeout(Rec
overy.java:46)
        at org.agilewiki.jactor2.core.impl.mtReactors.ReactorMtImpl.reactorPoll(
ReactorMtImpl.java:624)
        at org.agilewiki.jactor2.core.impl.mtReactors.ReactorMtImpl.reactorPoll(
ReactorMtImpl.java:634)
        at org.agilewiki.jactor2.core.impl.mtPlant.PlantMtImpl$1.run(PlantMtImpl
.java:270)
        at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:47
1)
        at java.util.concurrent.FutureTask.runAndReset(FutureTask.java:304)
        at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.
access$301(ScheduledThreadPoolExecutor.java:178)
        at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.
run(ScheduledThreadPoolExecutor.java:293)
        at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.
java:1145)
        at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor
.java:615)
        at java.lang.Thread.run(Thread.java:745)
</pre>
<h2>Hung Threads</h2>
<p>
When there is no response to an interrupt, the thread is considered hung and the
Recovery method
<a href="../../api/coreMt/org/agilewiki/jactor2/core/impl/mtPlant/Recovery.html#onHungThread-org.agilewiki.jactor2.core.reactors.impl.ReactorImpl-">onHungThread</a>
is called to handle the recovery.
The default action is to call the 
<a href="../../api/core/org/agilewiki/jactor2/core/plant/PlantBase.html#close--">close</a> method on Plant
before calling System.exit.
</p>
<p>
The <a href="java7/LooperMessageTimeout.java">LooperMessageTimeout</a> program
calls the looper request on Hanger, resulting in a hung thread and then termination
of the program.
</p>
<pre>
import org.agilewiki.jactor2.core.impl.Plant;

public class LooperMessageTimeout {
    static public void main(final String[] _args) throws Exception {
        final Plant plant = new Plant();
        try {
            Hanger hanger = new Hanger();
            hanger.looperSOp().signal();
            Thread.sleep(Long.MAX_VALUE);
        } finally {
            plant.close();
        }
    }
}

    Output:
    
[pool-1-thread-1] ERROR org.agilewiki.jactor2.core.reactors.Reactor - message ti
meout -> reactor close
[pool-1-thread-1] ERROR org.agilewiki.jactor2.core.reactors.Reactor - hung threa
d
message=looper, isComplete=true, isOneWay=true, source=null, target=org.agilewik
i.jactor2.core.impl.mtReactors.NonBlockingReactorMtImpl@5dccb1ae, this=org.agile
wiki.jactor2.core.impl.mtRequests.SyncRequestMtImpl@79b2dc6
[pool-1-thread-1] ERROR org.agilewiki.jactor2.core.reactors.Reactor - hung threa
d -> plant exit
</pre>
<h2>Hung Asynchronous Operations</h2>
<p>
When working with asynchronous operations, it is easy to forget to send a response.
Then the program hangs without a hint as to what went wrong. So a bit of logic has been
added to detect this situation.
</p>
<p>
As we saw in <a href="parallel.html">Parallel</a>,
an AsyncRequest tracks the number of pending requests.
So when a message is done processing, there is no response yet for the
current request and there are no pending responses, it is quite likely that
there is a bug and the request has been hung.
This is when the recovery method
<a href="../../api/coreMt/org/agilewiki/jactor2/core/impl/mtPlant/Recovery.html#onHungRequest-org.agilewiki.jactor2.core.impl.mtRequests.RequestMtImpl-">onHungRequest</a>
is called.
The default action is to close the reactor.
</p>
<p>
Of course, things are often not that simple. A blade may save a request and respond to it later.
In this case we need to call
<a href="../../api/core/org/agilewiki/jactor2/core/requests/impl/AsyncRequestImpl.html#setNoHungRequestCheck--">setNoHungRequestCheck</a>.
Fortunately this is an unusual case, so most of the time we are assured that the request will not hang
and we can focus our code reviews on code that uses the setNoHungRequestCheck method.
</p>
<p>
The <a href="java7/AsyncHang.java">AsyncHang</a> program
demonstrates what happens when there is no response to an asynchronous request.
</p>
<pre>
import org.agilewiki.jactor2.core.blades.NonBlockingBladeBase;
import org.agilewiki.jactor2.core.impl.Plant;
import org.agilewiki.jactor2.core.requests.AOp;
import org.agilewiki.jactor2.core.requests.AsyncResponseProcessor;
import org.agilewiki.jactor2.core.requests.impl.AsyncRequestImpl;

public class AsyncHang extends NonBlockingBladeBase {

    public static void main(final String[] _args) throws Exception {
        new Plant();
        try {
            AsyncHang asyncHang = new AsyncHang();
            asyncHang.hangAOp().call();
        } finally {
            Plant.close();
        }
    }

    public AsyncHang() throws Exception {
    }

    public AOp&lt;Void&gt; hangAOp() {
        return new AOp&lt;Void&gt;("hang", getReactor()) {
            @Override
            protected void processAsyncOperation(AsyncRequestImpl _asyncRequestImpl, 
					AsyncResponseProcessor&lt;Void&gt; _asyncResponseProcessor) throws Exception {
                //no response--the request hangs
            }
        };
    }
}


    Output:
    
[Thread-0] ERROR org.agilewiki.jactor2.core.reactors.Reactor - hung request:
message=hang, isComplete=false, isOneWay=false, source=org.agilewiki.jactor2.cor
e.impl.mtRequests.RequestMtImpl$Pender@10dca5b7, target=org.agilewiki.jactor2.co
re.impl.mtReactors.NonBlockingReactorMtImpl@1425a311, this=org.agilewiki.jactor2
.core.impl.mtRequests.AsyncRequestMtImpl@6039a07
[Thread-0] ERROR org.agilewiki.jactor2.core.reactors.Reactor - request hung -> r
eactor close
Exception in thread "main" org.agilewiki.jactor2.core.reactors.ReactorClosedExce
ption
        at org.agilewiki.jactor2.core.impl.mtRequests.RequestMtImpl.close(Reques
tMtImpl.java:345)
        at org.agilewiki.jactor2.core.impl.mtRequests.AsyncRequestMtImpl.close(A
syncRequestMtImpl.java:219)
        at org.agilewiki.jactor2.core.impl.mtRequests.AsyncRequestMtImpl.pending
Check(AsyncRequestMtImpl.java:108)
        at org.agilewiki.jactor2.core.impl.mtRequests.AsyncRequestMtImpl.process
RequestMessage(AsyncRequestMtImpl.java:117)
        at org.agilewiki.jactor2.core.impl.mtRequests.RequestMtImpl.eval(Request
MtImpl.java:370)
        at org.agilewiki.jactor2.core.impl.mtReactors.ReactorMtImpl.processMessa
ge(ReactorMtImpl.java:488)
        at org.agilewiki.jactor2.core.impl.mtReactors.ReactorMtImpl.run(ReactorM
tImpl.java:577)
        at org.agilewiki.jactor2.core.impl.mtPlant.ReactorPoolThreadManager$1.ru
n(ReactorPoolThreadManager.java:78)
        at java.lang.Thread.run(Thread.java:745)
</pre>
</body>
</html>
