<html>
<body>
<p>
<a href="https://github.com/laforge49/JActor2#readme">JActor2</a> &gt; <a href="../../index.html">Docs</a> &gt; <a href="../index.html">Tutorials</a> &gt; <a href="index.html">Core</a> &gt; Recovery
</p>
<h1>Recovery - When failures occur</h1>
<p>
In <a href="gettingStarted.html">Getting Started</a> we saw how we could change the plant configuration using a system property
to specify a subclass of
<a href="../../api/org/agilewiki/jactor2/core/plant/PlantConfiguration.html">PlantConfiguration</a>.
Alternatively, you can use a
<a href="../../api/org/agilewiki/jactor2/core/plant/Plant.html#Plant-org.agilewiki.jactor2.core.plant.PlantConfiguration-">Plant constructor</a>
to specify the desired subclass of PlantConfiguration.
</p>
<p>
The <a href="../../api/org/agilewiki/jactor2/core/plant/Recovery.html">Recovery</a> class
is included in PlantConfiguration. Recovery defines both failure detection and recovery.
Changing the Recovery class is done by overriding the 
<a href="../../api/org/agilewiki/jactor2/core/plant/PlantConfiguration.html#createRecovery--">createRecovery</a> method
in a subclass of PlantConfiguration.
</p>
When the
<a href="../../api/org/agilewiki/jactor2/core/plant/Plant.html">Plant</a> singleton is created,
it creates a reactor for internal use and assigns the Recovery object found in its PlantConfiguration using the
<a href="../../api/org/agilewiki/jactor2/core/reactors/Reactor.html#setRecovery-org.agilewiki.jactor2.core.plant.Recovery-">setRecovery</a>
method. When subsequent reactors are created, they are assigned the same recovery object as their parent reactor--which is,
by default, the internal reactor of the plant.
<p>
Failures may occur when a reactor processes a request or response message. Three types of failure are handled by Recovery: 
message timeout, hung thread and hung asynchronous request. Which reactor is used to handle a failure is determined by the reactor 
processing the message that caused the failure.
</p>
<h2>Message Timeouts</h2>
<p>
When there are millions of messages processed each second, adding a timer to each one can slow things down considerably.
So instead of timing each message, the reactor tracks when processing began on each message and the reactors are polled
to see if any reactor has been processing the same message for too long. The Recovery method
<a href="../../api/org/agilewiki/jactor2/core/plant/Recovery.html#getReactorPollMillis--">getReactorPollMillis</a>
is used to determine how often the reactors are to be polled. The default value is 500 milliseconds.
</p>
<p>
The Recovery method
<a href="../../api/org/agilewiki/jactor2/core/plant/Recovery.html#getMessageTimeoutMillis-org.agilewiki.jactor2.core.impl.ReactorImpl-">getMessageTimeoutMillis</a>
is used to determine how long a message can be processed before being timed out. The default value is
300,000 milliseconds for blocking reactors and 1,000 milliseconds for all other types of reactors.
</p>
<p>
Once a message has timed out, then the Recovery method
<a href="../../api/org/agilewiki/jactor2/core/plant/Recovery.html#onMessageTimeout-org.agilewiki.jactor2.core.impl.ReactorImpl-">onMessageTimeout</a>
handles the recovery. The default action is to close the Reactor, which results in an interrupt being passed to the thread processing the message. 
The application then has a limited
time to detect and throw an InterruptedException. How long it has is determined by the Recovery method
<a href="../../api/org/agilewiki/jactor2/core/plant/Recovery.html#getThreadInterruptMillis-org.agilewiki.jactor2.core.impl.ReactorImpl-">getThreadInterruptMillis</a>.
The default value is 1,000 milliseconds.
</p>
<p>
If the application logic throws the InterruptedException in time, then the Reactor is successfully closed and all incomplete request are given
a ServiceClosedException.
But if the application logic does not throw an InterruptedException
(or complete the message processing) in time, then the thread is considered hung--which is a far more serious issue.
</p>
<p>
The <a href="java7/Hanger.java">Hanger</a> class is used to test message timeouts.
It has two synchronous requests, sleeper and looper.
The sleeper requests causes a message timeout but uses Thread.sleep which responds to a thread interrupt by throwing an InterruptedException.
In contrast, the looper request does not check to see if the thread has received an interrupt.
</p>
<pre>
import org.agilewiki.jactor2.core.blades.NonBlockingBladeBase;
import org.agilewiki.jactor2.core.reactors.NonBlockingReactor;
import org.agilewiki.jactor2.core.requests.SyncRequest;

class Hanger extends NonBlockingBladeBase {
    Hanger() throws Exception {
        super(new NonBlockingReactor());
    }

    SyncRequest&lt;Void&gt; looperSReq() {
        return new SyncBladeRequest&lt;Void&gt;() {
            @Override
            public Void processSyncRequest() throws Exception {
                while (true) {}
            }
        };
    }

    SyncRequest&lt;Void&gt; sleeperSReq() {
        return new SyncBladeRequest&lt;Void&gt;() {
            @Override
            public Void processSyncRequest() throws Exception {
                try {
                    Thread.sleep(Long.MAX_VALUE);
                } catch (InterruptedException ie) {
                    throw ie;
                }
                return null;
            }
        };
    }
}
</pre>
<p>
The <a href="java7/SleeperMessageTimeout.java">SleeperMessageTimeout</a> program
calls the sleeper request to demonstrate the result of a message timeout.
As you can see below, the Hanger's reactor is closed and the result of the call to
sleeper is that a ServiceClosedException is thrown.
</p>
<pre>
import org.agilewiki.jactor2.core.plant.Plant;

public class SleeperMessageTimeout {
    static public void main(final String[] _args) throws Exception {
        final Plant plant = new Plant();
        try {
            Hanger hanger = new Hanger();
            hanger.sleeperSReq().call();
            System.out.println("never gets here");
        } finally {
            plant.close();
        }
    }
}

    Output:
    
[pool-1-thread-1] ERROR org.agilewiki.jactor2.core.reactors.Reactor - message ti
meout -> reactor close
[Thread-0] WARN org.agilewiki.jactor2.core.reactors.Reactor - message interrupte
d on close message=Hanger$2, isClosed=false, isSignal=false, source=org.agilewik
i.jactor2.core.impl.RequestImplBase$Pender, target=org.agilewiki.jactor2.core.re
actors.NonBlockingReactor, this=org.agilewiki.jactor2.core.impl.SyncRequestImpl@
28741fab
Exception in thread "main" org.agilewiki.jactor2.core.plant.ServiceClosedExcepti
on
        at org.agilewiki.jactor2.core.impl.RequestImplBase.close(RequestImplBase
.java:288)
        at org.agilewiki.jactor2.core.impl.ReactorImpl.close2(ReactorImpl.java:2
02)
        at org.agilewiki.jactor2.core.impl.ReactorImpl.closeAll(ReactorImpl.java
:549)
        at org.agilewiki.jactor2.core.impl.ReactorImpl.close(ReactorImpl.java:16
7)
        at org.agilewiki.jactor2.core.plant.Recovery.onMessageTimeout(Recovery.j
ava:22)
        at org.agilewiki.jactor2.core.impl.ReactorImpl.reactorPoll(ReactorImpl.j
ava:482)
        at org.agilewiki.jactor2.core.impl.ReactorImpl.reactorPoll(ReactorImpl.j
ava:491)
        at org.agilewiki.jactor2.core.impl.PlantImpl$1.run(PlantImpl.java:76)
        at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:51
1)
        at java.util.concurrent.FutureTask.runAndReset(FutureTask.java:308)
        at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.
access$301(ScheduledThreadPoolExecutor.java:180)
        at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.
run(ScheduledThreadPoolExecutor.java:294)
        at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.
java:1142)
        at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor
.java:617)
        at java.lang.Thread.run(Thread.java:744)
</pre>
<h2>Hung Threads</h2>
<p>
When there is no response to an interrupt, the thread is considered hung and the
Recovery method
<a href="../../api/org/agilewiki/jactor2/core/plant/Recovery.html#onHungThread-org.agilewiki.jactor2.core.impl.ReactorImpl-">onHungThread</a>
is called to handle the recovery.
The default action is to call the 
<a href="../../api/org/agilewiki/jactor2/core/plant/Plant.html#exit--">exit</a> method on Plant.
This method closes all reactors and their closeables before calling System.exit.
</p>
<p>
The <a href="java7/LooperMessageTimeout.java">LooperMessageTimeout</a> program
calls the looper request on Hanger, resulting in a hung thread and then termination
of the program.
</p>
<pre>
import org.agilewiki.jactor2.core.plant.Plant;

public class LooperMessageTimeout {
    static public void main(final String[] _args) throws Exception {
        final Plant plant = new Plant();
        try {
            Hanger hanger = new Hanger();
            hanger.looperSReq().signal();
            Thread.sleep(Long.MAX_VALUE);
        } finally {
            plant.close();
        }
    }
}

    Output:
    
[pool-1-thread-1] ERROR org.agilewiki.jactor2.core.reactors.Reactor - message ti
meout -> reactor close
[pool-1-thread-1] ERROR org.agilewiki.jactor2.core.reactors.Reactor - hung threa
d
message=Hanger$1, isClosed=true, isSignal=true, source=null, target=org.agilewik
i.jactor2.core.reactors.NonBlockingReactor, this=org.agilewiki.jactor2.core.impl
.SyncRequestImpl@1b4f5062
</pre>
<h2>Hung Asynchronous Requests</h2>
<p>
When working with asynchronous requests, it is easy to forget to send a response.
Then the program hangs without a hint as to what went wrong. So a bit of logic has been
added to detect this situation.
</p>
<p>
As we saw in <a href="parallel.html">Parallel</a>,
an AsyncRequest tracks the number of pending requests.
So when a message is done processing, there is no response yet for the
current request and there are no pending responses, it is quite likely that
there is a bug and the request has been hung.
This is when the recovery method
<a href="../../api/org/agilewiki/jactor2/core/plant/Recovery.html#onHungRequest-org.agilewiki.jactor2.core.impl.RequestImpl-">onHungRequest</a>
is called.
The default action is to close the reactor.
</p>
<p>
Of course, things are often not that simple. A blade may save a request and respond to it later.
In this case we need to call
<a href="../../api/org/agilewiki/jactor2/core/plant/Recovery.html#setNoHungRequestCheck--">setNoHungRequestCheck</a>.
Fortunately this is an unusual case, so most of the time we are assured that the request will not hang
and we can focus our code reviews on code that uses the setNoHungRequestCheck method.
</p>
<p>
The <a href="java7/AsyncHang.java">AsyncHang</a> program
demonstrates what happens when there is no response to an asynchronous request.
</p>
<pre>
import org.agilewiki.jactor2.core.blades.NonBlockingBladeBase;
import org.agilewiki.jactor2.core.plant.Plant;
import org.agilewiki.jactor2.core.requests.AsyncRequest;

public class AsyncHang extends NonBlockingBladeBase {

    public static void main(final String[] _args) throws Exception {
        new Plant();
        try {
            AsyncHang asyncHang = new AsyncHang();
            asyncHang.hangAReq().call();
        } finally {
            Plant.close();
        }
    }

    public AsyncHang() throws Exception {
    }

    public AsyncRequest<Void> hangAReq() {
        return new AsyncBladeRequest<Void>() {
            @Override
            public void processAsyncRequest() throws Exception {
                //no response--the request hangs
            }
        };
    }
}

    Output:
    
[Thread-0] ERROR org.agilewiki.jactor2.core.reactors.Reactor - hung request:
message=AsyncHang$1, isClosed=false, isSignal=false, source=org.agilewiki.jactor
2.core.impl.RequestImplBase$Pender, target=org.agilewiki.jactor2.core.reactors.N
onBlockingReactor, this=org.agilewiki.jactor2.core.impl.AsyncRequestImpl@ff60fc4

[Thread-0] ERROR org.agilewiki.jactor2.core.reactors.Reactor - request hung -> r
eactor close
Exception in thread "main" org.agilewiki.jactor2.core.plant.ServiceClosedExcepti
on
        at org.agilewiki.jactor2.core.impl.RequestImplBase.close(RequestImplBase
.java:288)
        at org.agilewiki.jactor2.core.impl.AsyncRequestImpl.pendingCheck(AsyncRe
questImpl.java:62)
        at org.agilewiki.jactor2.core.impl.AsyncRequestImpl.processRequestMessag
e(AsyncRequestImpl.java:70)
        at org.agilewiki.jactor2.core.impl.RequestImplBase.eval(RequestImplBase.
java:303)
        at org.agilewiki.jactor2.core.impl.ReactorImpl.processMessage(ReactorImp
l.java:367)
        at org.agilewiki.jactor2.core.impl.ReactorImpl.run(ReactorImpl.java:460)

        at org.agilewiki.jactor2.core.plant.ThreadManager$1.run(ThreadManager.ja
va:76)
        at java.lang.Thread.run(Thread.java:744)
</pre>
</body>
</html>
