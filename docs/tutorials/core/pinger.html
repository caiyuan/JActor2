<html>
<body>
<p>
<a href="https://github.com/laforge49/JActor2#readme">JActor2</a> &gt; <a href="../../index.html">Docs</a> &gt; <a href="../index.html">Tutorials</a> &gt; <a href="index.html">Core</a> &gt; Pinger
</p>
<h1>Pinger - Send Methods per Second</h1>
<p>
The <a href="Pinger.java">Pinger</a> blade is a minor variation on 
the <a href="loop.html">Loop</a> blade that uses <a href="ponger.html">Ponger</a> instead of Printer.
</p>
<pre>
import org.agilewiki.jactor2.core.blades.NonBlockingBladeBase;
import org.agilewiki.jactor2.core.messages.AsyncRequest;
import org.agilewiki.jactor2.core.messages.AsyncResponseProcessor;
import org.agilewiki.jactor2.core.messages.SyncRequest;
import org.agilewiki.jactor2.core.reactors.NonBlockingReactor;

public class Pinger extends NonBlockingBladeBase {
    private final Ponger ponger;

    public Pinger(final NonBlockingReactor _reactor, final Ponger _ponger) throws Exception {
        initialize(_reactor);
        ponger = _ponger;
    }

    public AsyncRequest&lt;Void&gt; loopAReq(final long _count) {
        return new AsyncBladeRequest&lt;Void&gt;() {
            final AsyncResponseProcessor&lt;Void&gt; dis = this;
            long i = 0;

            final AsyncResponseProcessor&lt;Long&gt; pingResponseProcessor = 
                    new AsyncResponseProcessor&lt;Long&gt;() {

                @Override
                public void processAsyncResponse(final Long _response) throws Exception {
                    i++;
                    iterate();
                }
            };

            @Override
            public void processAsyncRequest() throws Exception {
                iterate();
            }
            
            public void iterate() throws Exception {
                if (i >= _count) {
                    dis.processAsyncResponse(null);
                    return;
                }
                SyncRequest&lt;Long&gt; ping = ponger.pingSReq();
                send(ping, pingResponseProcessor);
            }
        };
    }
}
</pre>
<h3>
<a href="NativeSendSpeedReport.java">NativeSendSpeedReport</a>
</h3>
<p>
The speed of send depends largely on the relationship between the originating and target blades.
We will first look at the case where the two blades share the same reactor.
In this case, the local method should be used if the request being sent is a SyncRequest and
it is known that the blades share a reactor. But this is not always the case.
</p>
<pre>
import org.agilewiki.jactor2.core.facilities.BasicPlant;
import org.agilewiki.jactor2.core.facilities.Plant;
import org.agilewiki.jactor2.core.messages.AsyncRequest;
import org.agilewiki.jactor2.core.reactors.NonBlockingReactor;

public class NativeSendSpeedReport {
    public static void main(final String[] _args) throws Exception {
        final long count = 100000000L;
        BasicPlant plant = new Plant();
        try {
            NonBlockingReactor sharedReactor = new NonBlockingReactor(plant);
            Ponger ponger = new Ponger(sharedReactor);
            Pinger pinger = new Pinger(sharedReactor, ponger);
            AsyncRequest&lt;Void&gt; loopAReq = pinger.loopAReq(count);
            final long before = System.nanoTime();
            loopAReq.call();
            final long after = System.nanoTime();
            final long duration = after - before;
            SpeedReport.startAReq(plant, "Native Send Timings", duration, count).call();
        } finally {
            plant.close();
        }
    }
}

Output:

Native Send Timings
Test duration in nanoseconds: 23,721,347,417
Number of exchanges: 100,000,000
Exchanges per second: 4,215,612
</pre>
<p>
This is slower than when using the local method, but then asynchronous processing has more overhead:
</p>
<pre>
Local Timings
Test duration in nanoseconds: 15,204,566,434
Number of exchanges: 500,000,000
Exchanges per second: 32,884,857
</pre>
<h3>
<a href="ForeignSendSpeedReport.java">ForeignSendSpeedReport</a>
</h3>
<p>
A very common case is sending a request between two blades which have different reactors:
</p>
<pre>
import org.agilewiki.jactor2.core.facilities.BasicPlant;
import org.agilewiki.jactor2.core.facilities.Plant;
import org.agilewiki.jactor2.core.messages.AsyncRequest;
import org.agilewiki.jactor2.core.reactors.NonBlockingReactor;

public class ForeignSendSpeedReport {
    public static void main(final String[] _args) throws Exception {
        final long count = 10000000L;
        BasicPlant plant = new Plant();
        try {
            Ponger ponger = new Ponger(new NonBlockingReactor(plant));
            Pinger pinger = new Pinger(new NonBlockingReactor(plant), ponger);
            AsyncRequest&lt;Void&gt; loopAReq = pinger.loopAReq(count);
            final long before = System.nanoTime();
            loopAReq.call();
            final long after = System.nanoTime();
            final long duration = after - before;
            SpeedReport.startAReq(plant, "Foreign Send Timings", duration, count).call();
        } finally {
            plant.close();
        }
    }
}
</pre>
<p>
In this case the send is, as you would expect, much slower than when the two blades use a common reactor:
</p>
<pre>
Foreign Send Timings
Test duration in nanoseconds: 5,132,493,388
Number of exchanges: 10,000,000
Exchanges per second: 1,948,370
</pre>
<p>
Even slow, a send between two blades with different reactors but part of the same facility is
much faster than when using a call method from a non-pool thread:
</p>
<pre>
Call Timings
Test duration in nanoseconds: 5,970,590,691
Number of exchanges: 1,000,000
Exchanges per second: 167,487
</pre>
</body>
</html>
