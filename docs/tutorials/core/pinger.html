<html>
<head> <title>Asynchronous Loops</title>
</head>
<body>
<p>
<a href="https://github.com/laforge49/JActor2#readme">JActor2</a> &gt; <a href="../../index.html">Docs</a> &gt; <a href="../index.html">Tutorials</a> &gt; <a href="index.html">Core</a> &gt; Pinger
</p>
<h1>Pinger - Asynchronous Loops</h1>
<p>
Asynchronous loops have a unique form because a callback is needed to receive the results of each iteration.
But it is all about the callback or, in the case of JActor2, the anonymous AsyncResponseProcessor.
The <a href="java7/Pinger.java">Pinger</a> blade is a good example of such a loop:
</p>
<pre>
import org.agilewiki.jactor2.core.blades.NonBlockingBladeBase;
import org.agilewiki.jactor2.core.requests.AOp;
import org.agilewiki.jactor2.core.requests.SAOp;
import org.agilewiki.jactor2.core.requests.AsyncResponseProcessor;
import org.agilewiki.jactor2.core.requests.SOp;
import org.agilewiki.jactor2.core.reactors.NonBlockingReactor;
import org.agilewiki.jactor2.core.requests.impl.AsyncRequestImpl;

public class Pinger extends NonBlockingBladeBase {
    private final Ponger ponger;
    private final SOp&lt;Long&gt; pingSOp = ponger.pingSOp();

    public Pinger(final NonBlockingReactor _reactor, final Ponger _ponger) {
        super(_reactor);
        ponger = _ponger;
        pingSOp = ponger.pingSOp();
    }

    public AOp&lt;Void&gt; loopAOp(final long _count) {
        return new SAOp&lt;Void&gt;("loop", getReactor()) {
            long i = 0;

            final AsyncResponseProcessor&lt;Long&gt; pingResponseProcessor = 
                    new AsyncResponseProcessor&lt;Long&gt;() {
                @Override
                public void processAsyncResponse(final Long _response) throws Exception {
                    i++;
                    iterate();
                }
            };

            @Override
            protected void processAsyncOperation(final AsyncRequestImpl _asyncRequestImpl) throws Exception {
                iterate();
            }
            
            public void iterate() throws Exception {
                if (i &gt;= _count) {
                    processAsyncResponse(null);
                    return;
                }
                getAsyncRequestImpl().send(pingSOp, pingResponseProcessor);
            }
        };
    }
}
</pre>
<h3>
<a href="../../api/core/org/agilewiki/jactor2/core/requests/SAOp.html">SAOp</a>
Instances Not Reusable
</h3>
<pre>
            long i = 0;
</pre>
<p>
The index variable i is a member of the anonymous SAOp, rather than being a member of the Pinger blade.
And because ASOp operations are not reusable, the state of each operation is completely isolated from the state of
all other operations. Intermediate state should be kept as part of the operation state, not as part of the blade state.
</p>
<p>
One exception to this rule is when performing I/O, where intermediate state can not be isolated from different
requests. This is why blades which perform I/O may sometimes need to use an IsolationReactor, which 
processes each operation to completion before processing the next operation.
</p>
<h3>
processAsyncOperation
</h3>
<pre>
            @Override
            protected void processAsyncOperation(final AsyncRequestImpl _asyncRequestImpl) throws Exception {
                iterate();
            }
</pre>
<p>
The processAsyncOperation method is called to process the loop operation sent to this blade.
This method then begins invoking Ponger's pingSOp until the count is reached.
</p>
<h3>
iterate
</h3>
<pre>
            public void iterate() {
                if (i &gt;= _count) {
                    processAsyncResponse(null);
                    return;
                }
                getAsyncRequestImpl().send(pingSOp, pingResponseProcessor);
            }
</pre>
<p>
The iterate method performs the actual loop.
First the index variable, i, is compared with count.
And if no further iterations are needed, the loop request completes by passing back a null result.
Otherwise the ping request is sent to ponger
and the pingResponseProcessor is used as a callback to process the response from the send.
</p>
<h3>
pingResponseProcessor
</h3>
<pre>
            final AsyncResponseProcessor&lt;Long&gt; pingResponseProcessor = 
                    new AsyncResponseProcessor&lt;Long&gt;() {
                @Override
                public void processAsyncResponse(final Long _response) {
                    i++;
                    iterate();
                }
            };
</pre>
<p>
The pingResponseProcessor is used to process the response from a ping request sent to the Ponger blade.
Receipt of the response triggers the next iteration of the loop, as needed.
</p>
<h2>
<a href="java7/NativeSendSpeedReport.java">NativeSendSpeedReport</a>
</h2>
<p>
The speed of send depends largely on the relationship between the originating and target blades.
We will first look at the case where the two blades share the same reactor.
In this case, the local method should be used if the request being sent is a SyncRequest and
it is known that the blades share a reactor. But this is not always the case.
</p>
<pre>
import org.agilewiki.jactor2.core.impl.Plant;
import org.agilewiki.jactor2.core.requests.AOp;
import org.agilewiki.jactor2.core.reactors.NonBlockingReactor;

public class NativeSendSpeedReport {
    public static void main(final String[] _args) throws Exception {
        final long count = 100000000L;
        new Plant();
        try {
            Ponger ponger = new Ponger();
            NonBlockingReactor sharedReactor = (NonBlockingReactor) ponger.getReactor();
            Pinger pinger = new Pinger(sharedReactor, ponger);
            AOp&lt;Void&gt; loopAOp = pinger.loopAOp(count);
            final long before = System.nanoTime();
            loopAOp.call();
            final long after = System.nanoTime();
            final long duration = after - before;
            SpeedReport.print("Native Send Timings", duration, count);
        } finally {
            Plant.close();
        }
    }
}

Output:

Native Send Timings
Test duration in nanoseconds: 33256924805
Number of exchanges: 100000000
Exchanges per second: 3006892
Latency in seconds: 3.3256924805E-7
</pre>
<p>
This is about 100 times slower than when using direct method calls, but then requests have a lot more overhead:
</p>
<pre>
Direct Timings
Test duration in nanoseconds: 4925392155
Number of exchanges: 2000000000
Exchanges per second: 406059037
Latency in seconds: 2.4626960775E-9
</pre>
<h2>
<a href="java7/ForeignSendSpeedReport.java">ForeignSendSpeedReport</a>
</h2>
<p>
A very common case is sending a request between two blades which have different reactors:
</p>
<pre>
import org.agilewiki.jactor2.core.impl.Plant;
import org.agilewiki.jactor2.core.requests.AOp;
import org.agilewiki.jactor2.core.reactors.NonBlockingReactor;

public class ForeignSendSpeedReport {
    public static void main(final String[] _args) throws Exception {
        final long count = 10000000L;
        new Plant();
        try {
            Ponger ponger = new Ponger();
            Pinger pinger = new Pinger(new NonBlockingReactor(), ponger);
            AOp&lt;Void&gt; loopAOp = pinger.loopAOp(count);
            final long before = System.nanoTime();
            loopAOp.call();
            final long after = System.nanoTime();
            final long duration = after - before;
            SpeedReport.print("Foreign Send Timings", duration, count);
        } finally {
            Plant.close();
        }
    }
}
</pre>
<p>
In this case the send is roughly twice as slow as when the two blades use a common reactor:
</p>
<pre>
Foreign Send Timings
Test duration in nanoseconds: 8201212896
Number of exchanges: 10000000
Exchanges per second: 1219331
Latency in seconds: 8.201212896E-7
</pre>
<p>
Even so, a send between two blades with different reactors is
still about 10 times faster than when using a call method:
</p>
<pre>
Call Timings
Test duration in nanoseconds: 7731381822
Number of exchanges: 1000000
Exchanges per second: 129342
Latency in seconds: 7.731381822E-6
</pre>
</body>
</html>
