<html>
<head> <title>Asynchronous Loops</title>
</head>
<body>
<p>
<a href="https://github.com/laforge49/JActor2#readme">JActor2</a> &gt; <a href="../../index.html">Docs</a> &gt; <a href="../index.html">Tutorials</a> &gt; <a href="index.html">Core</a> &gt; Pinger
</p>
<h1>Pinger - Asynchronous Loops</h1>
<p>
Asynchronous loops have a unique form because a callback is needed to receive the results of each iteration.
But it is all about the callback or, in the case of JActor2, the anonymous AsyncResponseProcessor.
The <a href="java7/Pinger.java">Pinger</a> blade is a good example of such a loop:
</p>
<pre>
import org.agilewiki.jactor2.core.blades.NonBlockingBladeBase;
import org.agilewiki.jactor2.core.requests.AsyncRequest;
import org.agilewiki.jactor2.core.requests.AsyncResponseProcessor;
import org.agilewiki.jactor2.core.requests.SyncRequest;
import org.agilewiki.jactor2.core.reactors.NonBlockingReactor;

public class Pinger extends NonBlockingBladeBase {
    private final Ponger ponger;

    public Pinger(final NonBlockingReactor _reactor, final Ponger _ponger) {
        super(_reactor);
        ponger = _ponger;
    }

    public AsyncRequest&lt;Void&gt; loopAReq(final long _count) {
        return new AsyncBladeRequest&lt;Void&gt;() {
            final AsyncRequest&lt;Void&gt; dis = this;
            long i = 0;

            final AsyncResponseProcessor&lt;Long&gt; pingResponseProcessor = 
                    new AsyncResponseProcessor&lt;Long&gt;() {

                @Override
                public void processAsyncResponse(final Long _response) {
                    i++;
                    iterate();
                }
            };

            @Override
            public void processAsyncRequest() {
                iterate();
            }
            
            public void iterate() {
                if (i >= _count) {
                    dis.processAsyncResponse(null);
                    return;
                }
                SyncRequest&lt;Long&gt; ping = ponger.pingSReq();
                send(ping, pingResponseProcessor);
            }
        };
    }
}
</pre>
<h3>
Requests are Not Reusable
</h3>
<pre>
            long i = 0;
</pre>
<p>
The index variable i is a member of the anonymous AsyncBladeRequest, rather than being a member of the Loop blade.
And because requests are not reusable, the state of each request is completely isolated from the state of
all other requests. Intermediate state should be kept as part of the request state, not as part of the blade state.
</p>
<p>
One exception to this rule is when performing I/O, where intermediate state can not be isolated from different
requests. This is why blades which perform I/O may sometimes need to use an IsolationReactor, which 
processes each request to completion before processing the next request.
</p>
<h3>
processAsyncRequest
</h3>
<pre>
            @Override
            public void processAsyncRequest() {
                iterate();
            }
</pre>
<p>
The processAsyncRequest method is called to process the loop request sent to this blade.
This method then begins invoking Ponger's pingSReq until the count is reached.
</p>
<h3>
iterate
</h3>
<pre>
            public void iterate() {
                if (i >= _count) {
                    dis.processAsyncResponse(null);
                    return;
                }
                SyncRequest&lt;Long&gt; ping = ponger.pingSReq();
                send(ping, pingResponseProcessor);
            }
</pre>
<p>
The iterate method performs the actual loop.
First the index variable, i, is compared with count.
And if no further iterations are needed, the loop request completes by passing back a null result.
Otherwise the ping request is sent to ponger
and the pingResponseProcessor is used as a callback to process the response from the send.
</p>
<h3>
pingResponseProcessor
</h3>
<pre>
            final AsyncResponseProcessor&lt;Long&gt; pingResponseProcessor = 
                    new AsyncResponseProcessor&lt;Long&gt;() {

                @Override
                public void processAsyncResponse(final Long _response) {
                    i++;
                    iterate();
                }
            };
</pre>
<p>
The pingResponseProcessor is used to process the response from a ping request sent to the Ponger blade.
Receipt of the response triggers the next iteration of the loop, as needed.
</p>
<h2>
<a href="java7/NativeSendSpeedReport.java">NativeSendSpeedReport</a>
</h2>
<p>
The speed of send depends largely on the relationship between the originating and target blades.
We will first look at the case where the two blades share the same reactor.
In this case, the local method should be used if the request being sent is a SyncRequest and
it is known that the blades share a reactor. But this is not always the case.
</p>
<pre>
import org.agilewiki.jactor2.core.plant.Plant;
import org.agilewiki.jactor2.core.requests.AsyncRequest;
import org.agilewiki.jactor2.core.reactors.NonBlockingReactor;

public class NativeSendSpeedReport {
    public static void main(final String[] _args) throws Exception {
        final long count = 100000000L;
        new Plant();
        try {
            Ponger ponger = new Ponger();
            NonBlockingReactor sharedReactor = (NonBlockingReactor) ponger.getReactor();
            Pinger pinger = new Pinger(sharedReactor, ponger);
            AsyncRequest&lt;Void&gt; loopAReq = pinger.loopAReq(count);
            final long before = System.nanoTime();
            loopAReq.call();
            final long after = System.nanoTime();
            final long duration = after - before;
            SpeedReport.print("Native Send Timings", duration, count);
        } finally {
            Plant.close();
        }
    }
}

Output:

Native Send Timings
Test duration in nanoseconds: 25610810971
Number of exchanges: 100000000
Exchanges per second: 3904601
Latency in seconds: 2.5610810971E-7
</pre>
<p>
This is about 200 times slower than when using direct method calls, but then requests have a lot more overhead:
</p>
<pre>
Direct Timings
Test duration in nanoseconds: 4083868524
Number of exchanges: 2000000000
Exchanges per second: 489731730
Latency in seconds: 2.041934262E-9
</pre>
<h2>
<a href="java7/ForeignSendSpeedReport.java">ForeignSendSpeedReport</a>
</h2>
<p>
A very common case is sending a request between two blades which have different reactors:
</p>
<pre>
import org.agilewiki.jactor2.core.facilities.Plant;
import org.agilewiki.jactor2.core.requests.AsyncRequest;
import org.agilewiki.jactor2.core.reactors.NonBlockingReactor;

public class ForeignSendSpeedReport {
    public static void main(final String[] _args) throws Exception {
        final long count = 10000000L;
        new Plant();
        try {
            Ponger ponger = new Ponger();
            Pinger pinger = new Pinger(new NonBlockingReactor(), ponger);
            AsyncRequest&lt;Void&gt; loopAReq = pinger.loopAReq(count);
            final long before = System.nanoTime();
            loopAReq.call();
            final long after = System.nanoTime();
            final long duration = after - before;
            SpeedReport.print("Foreign Send Timings", duration, count);
        } finally {
            Plant.close();
        }
    }
}
</pre>
<p>
In this case the send is roughly twice as slow as when the two blades use a common reactor:
</p>
<pre>
Foreign Send Timings
Test duration in nanoseconds: 5414567417
Number of exchanges: 10000000
Exchanges per second: 1846869
Latency in seconds: 5.414567417E-7
</pre>
<p>
Even so, a send between two blades with different reactors is
still about 10 times faster than when using a call method:
</p>
<pre>
Call Timings
Test duration in nanoseconds: 6162933014
Number of exchanges: 1000000
Exchanges per second: 162260
Latency in seconds: 6.162933014E-6
</pre>
</body>
</html>
