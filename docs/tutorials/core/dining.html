<html>
<body>
<p>
<a href="https://github.com/laforge49/JActor2#readme">JActor2</a> &gt; <a href="../../index.html">Docs</a> &gt; <a href="../index.html">Tutorials</a> &gt; <a href="index.html">Core</a> &gt; DiningPhilosophers
</p>
<h1>DiningPhilosophers - Pending Responses</h1>
<p>
The <a href="http://en.wikipedia.org/wiki/Dining_philosophers_problem">Dining Philosophers</a> 
is a classic problem in concurrency.
Five philosophers sit at a table with 5 place settings and 5 forks. 
Spaghetti is served, but the philosophers will only eat when they have two forks.
The philosophers, once they have both forks, will eat a meal and then return the forks to the table before eating again.
Our objective here is to see how fast our philosophers can eat.
</p>
<img src="http://upload.wikimedia.org/wikipedia/commons/thumb/6/6a/Dining_philosophers.png/578px-Dining_philosophers.png"></a>
<h2>DiningPhilosopher</h2>
<p>
As we are implementing our solution to this problem without built-in delays or locks, we will use 
dining philosophers who will eat as soon as they get both a left and right fork, put the forks back on the
table and then immediately try to pick up their forks and eat again. This differs a bit from other solutions where the philosophers
take time out to think when they can not immediately get a fork. 
<a href="DiningPhilosopher.java">Here</a> is the code used to model a dining philosopher:
</p>
<pre>
import org.agilewiki.jactor2.core.blades.NonBlockingBladeBase;
import org.agilewiki.jactor2.core.messages.AsyncRequest;
import org.agilewiki.jactor2.core.messages.AsyncResponseProcessor;
import org.agilewiki.jactor2.core.messages.SyncRequest;
import org.agilewiki.jactor2.core.reactors.NonBlockingReactor;

/*
Each philosopher has a seat at the table, and the seats are numbered from 0 through 4.
The DiningPhilosopher class implements a single public request, feastAReq, 
which returns the number of meals the philosopher ate once all the spaghetti was eaten.

The feast request executes a simple loop, calling eatAReq and ateSReq until eatAReq returns a result
of false--which indicates that there is no more food to eat.
*/
public class DiningPhilosopher extends NonBlockingBladeBase {
    public DiningPhilosopher(final NonBlockingReactor _reactor) throws Exception {
        initialize(_reactor);
    }
    
    public AsyncRequest&lt;Integer&gt; feastAReq(final DiningTable _diningTable, final int _seat)
            throws Exception {
        return new AsyncBladeRequest&lt;Integer&gt;() {
            final AsyncResponseProcessor&lt;Integer&gt; dis = this;
            
            private int mealsEaten; //The number of meals eaten by this philosopher.
            private AsyncResponseProcessor&lt;Void&gt; ateResponseProcessor;
            private AsyncResponseProcessor&lt;Boolean&gt; eatResponseProcessor;
            
            @Override
            public void processAsyncRequest() throws Exception {
            
                //The logic to process a response from a DiningTable.ateSReq.
                ateResponseProcessor = new AsyncResponseProcessor&lt;Void&gt;() {
                    @Override
                    public void processAsyncResponse(final Void _ateResponse) throws Exception {
                        AsyncRequest&lt;Boolean&gt; eatAReq = _diningTable.eatAReq(_seat);
                        send(eatAReq, eatResponseProcessor);
                    }
                };
                
                //The logic to process a response from a DiningTable.eatAReq.
                eatResponseProcessor = new AsyncResponseProcessor&lt;Boolean&gt;() {
                    @Override
                    public void processAsyncResponse(final Boolean _eatResponse) throws Exception {
                        if (!_eatResponse) {
                            //The food is gone, so return the number of meals eaten.
                            dis.processAsyncResponse(mealsEaten);
                            return;
                        }
                        mealsEaten++;
                        SyncRequest&lt;Void&gt; ateSReq = _diningTable.ateSReq(_seat);
                        send(ateSReq, ateResponseProcessor);
                    }
                };
                
                //Start by eating the first plate of spaghetti.
                AsyncRequest&lt;Boolean&gt; eatAReq = _diningTable.eatAReq(_seat);
                send(eatAReq, eatResponseProcessor);
            }
        };
    }
}
</pre>
<h2>DiningTable</h2>
<p>
The <a href="DiningTable.java">DiningTable</a> is responsible for managing the forks and serving up the spaghetti.
But it also does not respond to an eat request until either both forks are available or
there is no more spaghetti, whichever comes first.
</p>
<pre>
import org.agilewiki.jactor2.core.blades.NonBlockingBladeBase;
import org.agilewiki.jactor2.core.messages.AsyncRequest;
import org.agilewiki.jactor2.core.messages.AsyncResponseProcessor;
import org.agilewiki.jactor2.core.messages.SyncRequest;
import org.agilewiki.jactor2.core.reactors.NonBlockingReactor;

public class DiningTable extends NonBlockingBladeBase {
    public final int seats; //The number of seats around the table == the number of philosophers.
    public final int meals; //The number of plates of spaghetti to be eaten.
    
    private int mealsEaten; //The number of plates of spaghetti eaten to date.
    private int[] forkUsage;    //seat number which is using the fork, or -1 if available.
    private AsyncResponseProcessor&lt;Boolean&gt;[] pendingResponses; //Pending eat requests, or null.

    public DiningTable(final NonBlockingReactor _reactor, final int _seats, final int _meals) 
            throws Exception {
        initialize(_reactor);
        seats = _seats;
        meals = _meals;
        forkUsage = new int[seats];
        int i = 0;
        while (i < seats) {
            forkUsage[i] = -1;  //Mark the fork as available.
            i++;
        }
        pendingResponses = new AsyncResponseProcessor[seats]; //Initially there are no pending eat requests.
    }
    
    private int leftFork(final int _seat) {
        return _seat;
    }
    
    private int rightFork(final int _seat) {
        return (_seat + 1) % seats;
    }
    
    private boolean isForkAvailable(final int _seat) {
        return forkUsage[_seat] == -1;
    }
    
    /*
        Assign the forks to the left and right of the seat
        only if both forks are available.
    */
    private boolean getForks(final int _seat) {
        int leftFork = leftFork(_seat);
        int rightFork = rightFork(_seat);
        if (isForkAvailable(leftFork) && isForkAvailable(rightFork)) {
            forkUsage[leftFork] = _seat;
            forkUsage[rightFork] = _seat;
            return true;
        }
        return false;
    }
    
    /*
        The eatAReq is created and then invoked when the philosopher is ready 
        to eat another meal.
        
        When an eat request is received but there are no more meals to serve, 
        a response of false is passed back.

        If there are more meals remaining and both forks are acquired, then 
        call the chowTime method and a response of true is passed back to the 
        requesting philosopher.

        Otherwise, the response is left pending until either there is no more 
        spaghetti or both forks become available.
    */
    public AsyncRequest&lt;Boolean&gt; eatAReq(final int _seat) {
        return new AsyncBladeRequest&lt;Boolean&gt;() {
            final AsyncResponseProcessor&lt;Boolean&gt; dis = this;
            
            @Override
            public void processAsyncRequest() throws Exception {
                setNoHungRequestCheck(); //inhibit the test for hung request
                
                if (mealsEaten == meals) {  //There is no more food to be eaten.
                    dis.processAsyncResponse(false); //The feast is finished.
                    return;
                }
                
                if (getForks(_seat)) {  We have food and both forks, so lets eat!
                    chowTime(_seat);
                    dis.processAsyncResponse(true); //The philosopher has eaten another meal.
                    return;
                }
                
                pendingResponses[_seat] = dis; //The forks are not available, so respond to the eat request later.
            }
        };
    }
    
    /*
        The chowTime method increments the number of meals eaten by 1. Then if all the meals 
        have been eaten, the pending philosophers are passed back a false.
    */
    private void chowTime(final int _seat) throws Exception {
        mealsEaten++;   //One more meal has been eaten.
        if (mealsEaten == meals) {  //The food is gone, so process the pending eat requests.
            int i = 0;
            while (i < seats) {
                AsyncResponseProcessor<Boolean> pendingResponse = pendingResponses[i];
                if (pendingResponse != null) {
                    pendingResponse.processAsyncResponse(false);    //The feast is over.
                }
                i++;
            }
        }
    }
    
    private int leftSeat(final int _fork) {
        return (_fork + seats - 1) % seats;
    }
    
    private int rightSeat(final int _fork) {
        return _fork;
    }
    
    /*
        If there is a pending request for the seat, both forks are acquired and 
        there is some food left, then clear the pending request, call the chowTime 
        method and pass true back to the pending philosopher.
    */
    private void notice(final int _seat) throws Exception {
        AsyncResponseProcessor&lt;Boolean&gt; pendingResponse = pendingResponses[_seat];
        if (pendingResponse == null)
            return; //No response is pending.
        if (!getForks(_seat))
            return; //The forks are not yet available.
        pendingResponses[_seat] = null;
        if (mealsEaten < meals) {   //We have food and both forks, so lets eat.
            chowTime(_seat);
            pendingResponse.processAsyncResponse(true); //The philosopher has eaten another meal.
        }
    }
    
    /*
        The ateSReq is created and then invoked when a philosopher is finished eating a meal.
    */
    public SyncRequest&lt;Void&gt; ateSReq(final int _seat) {
        return new SyncBladeRequest&lt;Void&gt;() {
            @Override
            public Void processSyncRequest() throws Exception {
                int leftFork = leftFork(_seat);
                int rightFork = rightFork(_seat);
                forkUsage[leftFork] = -1;   //Done with the left fork for now.
                forkUsage[rightFork] = -1;  //Done with the right fork for now.
                notice(leftSeat(leftFork)); //See if the left seat has a response pending.
                notice(rightSeat(rightFork));   //See if the right seat has a response pending.
                return null;
            }
        };
    }
}
</pre>
<h2>DiningRoom</h2>
<p>
The <a href="DiningRoom.java">DiningRoom</a> class creates the dining table and the philosophers and invites the philosophers
to the feast. When all the meals have been eaten, the dining room validates and reports the result.
</p>
<pre>
import org.agilewiki.jactor2.core.blades.NonBlockingBladeBase;
import org.agilewiki.jactor2.core.blades.misc.Printer;
import org.agilewiki.jactor2.core.blades.misc.SyncPrinterRequest;
import org.agilewiki.jactor2.core.facilities.BasicPlant;
import org.agilewiki.jactor2.core.facilities.Plant;
import org.agilewiki.jactor2.core.messages.AsyncRequest;
import org.agilewiki.jactor2.core.messages.AsyncResponseProcessor;
import org.agilewiki.jactor2.core.messages.SyncRequest;
import org.agilewiki.jactor2.core.reactors.BlockingReactor;
import org.agilewiki.jactor2.core.reactors.NonBlockingReactor;

import java.util.Iterator;
import java.util.List;
import java.util.LinkedList;

public class DiningRoom extends NonBlockingBladeBase {
    public DiningRoom(final NonBlockingReactor _reactor)
            throws Exception {
        initialize(_reactor);
    }
    
    /*
        The dining room implements a feast request, which creates the dining table and 
        the philosophers and sends a feast request to all the philosophers. The result 
        returned is a list of the number of meals eaten by each philosopher.
    */
    public AsyncRequest&lt;List&lt;Integer&gt;&gt; feastAReq(final int _seats, final int _meals)
            throws Exception {
        return new AsyncBladeRequest&lt;List&lt;Integer&gt;&gt;() {
            final AsyncResponseProcessor&lt;List&lt;Integer&gt;&gt; dis = this;
            List&lt;Integer&gt; mealsEaten = new LinkedList&lt;Integer&gt;(); //The list passed back when the feast is done.
            
            /*
                Processes the response from a philosopher when he is done feasting.
            */
            AsyncResponseProcessor&lt;Integer&gt; feastResponseProcessor =
                new AsyncResponseProcessor&lt;Integer&gt;() {
                    @Override
                    public void processAsyncResponse(final Integer _feastResponse) 
                            throws Exception {
                        mealsEaten.add(_feastResponse);
                        if (mealsEaten.size() == _seats) {  //This is the response from the last philosopher.
                            dis.processAsyncResponse(mealsEaten);
                        }
                    }
            };
            
            /*
                Start the feast.
            */
            @Override
            public void processAsyncRequest() throws Exception {
                int i = 0;
                Reactor myReactor = getReactor();
                BasicPlant plant = myReactor.getPlant();
                DiningTable diningTable = new DiningTable(
                    new NonBlockingReactor(plant),
                    _seats,
                    _meals);
                while (i < _seats) {
                    DiningPhilosopher diningPhilosopher =
                        new DiningPhilosopher(new NonBlockingReactor(plant));
                    AsyncRequest&lt;Integer&gt; feastAReq = diningPhilosopher.feastAReq(diningTable, i);
                    send(feastAReq, feastResponseProcessor);
                    ++i;
                }
            }
        };
    }
    
    /*
        Prints the report.
    */
    public static SyncRequest<Void> report(
            final Printer _printer, 
            final int _seats, 
            final int _meals, 
            final List&lt;Integer&gt; _mealsEaten, 
            final long _duration) {
        return new SyncPrinterRequest(_printer) {
            @Override
            public Void processSyncRequest() throws Exception {
                printf("Seats: %,d%n", _seats);
                printf("Meals: %,d%n", _meals);
                println("\nMeals eaten by each philosopher:");
                Iterator&lt;Integer&gt; it = _mealsEaten.iterator();
                int totalEaten = 0;
                while (it.hasNext()) {
                    int me = it.next();
                    totalEaten += me;
                    if (_mealsEaten.size() < 11)
                        printf("    %,d%n", me);
                }
                if (totalEaten != _meals)
                    throw new IllegalStateException("total meals eaten does not match: " + totalEaten);
                printf("\nTest duration in nanoseconds: %,d%n", _duration);
                if (_duration > 0) {
                    printf("Total meals eaten per second: %,d%n%n", 1000000000L * _meals / _duration);
                }
                return null;
            }
        };
    }
    
    public static void main(String[] args) throws Exception {
        int seats = 5;
        int meals = 1000000;
        BasicPlant plant = new Plant();
        try {
            NonBlockingReactor diningRoomReactor = new NonBlockingReactor(plant);
            DiningRoom diningRoom = new DiningRoom(diningRoomReactor);
            AsyncRequest&lt;List&lt;Integer&gt;&gt; feastAReq = diningRoom.feastAReq(seats, meals);
            long before = System.nanoTime();
            List&lt;Integer&gt; mealsEaten = feastAReq.call(); //Run the feast.
            long after = System.nanoTime();
            long duration = after - before;
            Printer printer = new Printer(new BlockingReactor(plant));
            report(printer, seats, meals, mealsEaten, duration).call(); //Print the report.
        } finally {
            plant.close();
        }
    }
}
</pre>
<h3>Performance</h3>
<pre>
Output:

Seats: 5
Meals: 1,000,000

Meals eaten by each philosopher:
    158,202
    316,084
    178,295
    189,123
    158,296

Test duration in nanoseconds: 1,926,880,463
Total meals eaten per second: 518,973
</pre>
</body>
</html>
