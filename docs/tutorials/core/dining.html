<html>
<head>
<title>Pending Responses</title>
</head>
<body>
<p>
<a href="https://github.com/laforge49/JActor2#readme">JActor2</a> &gt; <a href="../../index.html">Docs</a> &gt; <a href="../index.html">Tutorials</a> &gt; <a href="index.html">Core</a> &gt; DiningPhilosophers
</p>
<h1>DiningPhilosophers - Pending Responses</h1>
<p>
The <a href="http://en.wikipedia.org/wiki/Dining_philosophers_problem">Dining Philosophers</a> 
is a classic problem in concurrency.
Five philosophers sit at a table with 5 place settings and 5 forks. 
Spaghetti is served, but the philosophers will only eat when they have two forks.
The philosophers, once they have both forks, will eat a meal and then return the forks to the table before eating again.
Our objective here is to see how fast our philosophers can eat.
</p>
<img src="http://upload.wikimedia.org/wikipedia/commons/thumb/6/6a/Dining_philosophers.png/578px-Dining_philosophers.png"></a>
<h2>DiningPhilosopher</h2>
<p>
As we are implementing our solution to this problem without built-in delays or locks, we will use 
dining philosophers who will eat as soon as they get both a left and right fork, put the forks back on the
table and then immediately try to pick up their forks and eat again. This differs a bit from other solutions where the philosophers
take time out to think when they can not immediately get a fork. 
<a href="java7/DiningPhilosopher.java">Here</a> is the code used to model a dining philosopher:
</p>
<pre>
import org.agilewiki.jactor2.core.blades.NonBlockingBladeBase;
import org.agilewiki.jactor2.core.requests.AOp;
import org.agilewiki.jactor2.core.requests.AsyncResponseProcessor;
import org.agilewiki.jactor2.core.requests.SOp;
import org.agilewiki.jactor2.core.requests.impl.AsyncRequestImpl;

/*
Each philosopher has a seat at the table, and the seats are numbered from 0 through 4.
The DiningPhilosopher class implements a single public request, feastAReq, 
which returns the number of meals the philosopher ate once all the spaghetti was eaten.

The feast request executes a simple loop, calling eatAReq and ateSReq until eatAReq returns a result
of false--which indicates that there is no more food to eat.
*/
public class DiningPhilosopher extends NonBlockingBladeBase {
	public DiningPhilosopher() throws Exception {
	}
	
    public AOp&lt;Integer&gt; feastAOp(final DiningTable _diningTable, final int _seat) {
        return new AOp&lt;Integer&gt;("feast", getReactor()) {
            private int mealsEaten; //The number of meals eaten by this philosopher.
            private AsyncResponseProcessor&lt;Void&gt; ateResponseProcessor;
            private AsyncResponseProcessor&lt;Boolean&gt; eatResponseProcessor;
            
            @Override
            protected void processAsyncOperation(final AsyncRequestImpl _asyncRequestImpl, 
					final AsyncResponseProcessor&lt;Integer&gt; _asyncResponseProcessor) throws Exception {
                //The logic to process a response from a DiningTable.ateSReq.
                ateResponseProcessor = new AsyncResponseProcessor&lt;Void&gt;() {
                    @Override
                    public void processAsyncResponse(final Void _ateResponse) {
                        AOp&lt;Boolean&gt; eatAOp = _diningTable.eatAOp(_seat);
                        _asyncRequestImpl.send(eatAOp, eatResponseProcessor);
                    }
                };
				
                //The logic to process a response from a DiningTable.eatAReq.
                eatResponseProcessor = new AsyncResponseProcessor&lt;Boolean&gt;() {
                    @Override
                    public void processAsyncResponse(final Boolean _eatResponse) throws Exception {
                        if (!_eatResponse) {
                            _asyncResponseProcessor.processAsyncResponse(mealsEaten);
                            return;
                        }
                        mealsEaten++;
                        SOp&lt;Void&gt; ateSReq = _diningTable.ateSOp(_seat);
                        _asyncRequestImpl.send(ateSReq, ateResponseProcessor);
                    }
                };
				
                //Start by eating the first plate of spaghetti.
                AOp&lt;Boolean&gt; eatAOp = _diningTable.eatAOp(_seat);
                _asyncRequestImpl.send(eatAOp, eatResponseProcessor);
            }
        };
    }
}
</pre>
<h2>DiningTable</h2>
<p>
The <a href="java7/DiningTable.java">DiningTable</a> is responsible for managing the forks and serving up the spaghetti.
But it also does not respond to an eat request until either both forks are available or
there is no more spaghetti, whichever comes first.
</p>
<pre>
import org.agilewiki.jactor2.core.blades.NonBlockingBladeBase;
import org.agilewiki.jactor2.core.requests.AOp;
import org.agilewiki.jactor2.core.requests.AsyncResponseProcessor;
import org.agilewiki.jactor2.core.requests.SOp;
import org.agilewiki.jactor2.core.requests.impl.RequestImpl;
import org.agilewiki.jactor2.core.requests.impl.AsyncRequestImpl;

public class DiningTable extends NonBlockingBladeBase {
    public final int seats; //The number of seats around the table == the number of philosophers.
    public final int meals; //The number of plates of spaghetti to be eaten.
    
    private int mealsEaten; //The number of plates of spaghetti eaten to date.
    private int[] forkUsage; //seat number which is using the fork, or -1 if available.
    private AsyncResponseProcessor&lt;Boolean&gt;[] pendingResponses; //Pending eat requests, or null.

    public DiningTable(final int _seats, final int _meals) throws Exception {
        seats = _seats;
        meals = _meals;
        forkUsage = new int[seats];
        int i = 0;
        while (i &lt; seats) {
            forkUsage[i] = -1;  //Mark the fork as available.
            i++;
        }
        pendingResponses = new AsyncResponseProcessor[seats]; //Initially there are no pending eat requests.
    }
    
    private int leftFork(final int _seat) {
        return _seat;
    }
    
    private int rightFork(final int _seat) {
        return (_seat + 1) % seats;
    }
    
    private boolean isForkAvailable(final int _seat) {
        return forkUsage[_seat] == -1;
    }
    
    /*
        Assign the forks to the left and right of the seat
        only if both forks are available.
    */
    private boolean getForks(final int _seat) {
        int leftFork = leftFork(_seat);
        int rightFork = rightFork(_seat);
        if (isForkAvailable(leftFork) && isForkAvailable(rightFork)) {
            forkUsage[leftFork] = _seat;
            forkUsage[rightFork] = _seat;
            return true;
        }
        return false;
    }
    
    /*
        The eatAOp is created and then invoked when the philosopher is ready 
        to eat another meal.
        
        When an eat request is received but there are no more meals to serve, 
        a response of false is passed back.

        If there are more meals remaining and both forks are acquired, then 
        call the chowTime method and a response of true is passed back to the 
        requesting philosopher.

        Otherwise, the response is left pending until either there is no more 
        spaghetti or both forks become available.
    */
    public AOp&lt;Boolean&gt; eatAOp(final int _seat) {
        return new AOp&lt;Boolean&gt;("eat", getReactor()) {
            @Override
            protected void processAsyncOperation(final AsyncRequestImpl _asyncRequestImpl, 
					final AsyncResponseProcessor&lt;Boolean&gt; _asyncResponseProcessor) throws Exception {
                _asyncRequestImpl.setNoHungRequestCheck(); //inhibit the test for hung request
                
                if (mealsEaten == meals) {  //There is no more food to be eaten.
                    _asyncResponseProcessor.processAsyncResponse(false); //The feast is finished.
                    return;
                }
                
                if (getForks(_seat)) { //We have food and both forks, so lets eat!
                    chowTime(_seat);
                    _asyncResponseProcessor.processAsyncResponse(true); //The philosopher has eaten another meal.
                    return;
                }
                
                pendingResponses[_seat] = _asyncResponseProcessor; //The forks are not available, so respond to the eat request later.
            }
        };
    }
    
    /*
        The chowTime method increments the number of meals eaten by 1. Then if all the meals 
        have been eaten, the pending philosophers are passed back a false.
    */
    private void chowTime(final int _seat) throws Exception {
        mealsEaten++; //One more meal has been eaten.
        if (mealsEaten == meals) { //The food is gone, so process the pending eat requests.
            int i = 0;
            while (i &lt; seats) {
                AsyncResponseProcessor&lt;Boolean&gt; pendingResponse = pendingResponses[i];
                if (pendingResponse != null) {
                    pendingResponse.processAsyncResponse(false); //The feast is over.
                }
                i++;
            }
        }
    }
    
    private int leftSeat(final int _fork) {
        return (_fork + seats - 1) % seats;
    }
    
    private int rightSeat(final int _fork) {
        return _fork;
    }

    /*
        If there is a pending request for the seat, both forks are acquired and 
        there is some food left, then clear the pending request, call the chowTime 
        method and pass true back to the pending philosopher.
    */
    private void notice(final int _seat) throws Exception {
        AsyncResponseProcessor&lt;Boolean&gt; pendingResponse = pendingResponses[_seat];
        if (pendingResponse == null)
            return; //No response is pending.
        if (!getForks(_seat))
            return; //The forks are not yet available.
        if (mealsEaten &lt; meals) { //We have food and both forks, so lets eat.
            pendingResponses[_seat] = null;
            chowTime(_seat);
            pendingResponse.processAsyncResponse(true); //The philosopher has eaten another meal.
        }
    }
    
    /*
        The ateSOp is created and then invoked when a philosopher is finished eating a meal.
    */
    public SOp&lt;Void&gt; ateSOp(final int _seat) {
        return new SOp&lt;Void&gt;("ate", getReactor()) {
            @Override
            protected Void processSyncOperation(final RequestImpl _requestImpl) throws Exception {
                int leftFork = leftFork(_seat);
                int rightFork = rightFork(_seat);
                forkUsage[leftFork] = -1; //Done with the left fork for now.
                forkUsage[rightFork] = -1; //Done with the right fork for now.
                notice(leftSeat(leftFork)); //See if the left seat has a response pending.
                notice(rightSeat(rightFork)); //See if the right seat has a response pending.
                return null;
            }
        };
    }
}
</pre>
<h2>DiningRoom</h2>
<p>
The <a href="java7/DiningRoom.java">DiningRoom</a> class creates the dining table and the philosophers and invites the philosophers
to the feast. When all the meals have been eaten, the dining room validates and reports the result.
</p>
<pre>
import org.agilewiki.jactor2.core.blades.NonBlockingBladeBase;
import org.agilewiki.jactor2.core.impl.Plant;
import org.agilewiki.jactor2.core.requests.AOp;
import org.agilewiki.jactor2.core.requests.AsyncResponseProcessor;
import org.agilewiki.jactor2.core.requests.SOp;
import org.agilewiki.jactor2.core.reactors.BlockingReactor;
import org.agilewiki.jactor2.core.requests.impl.AsyncRequestImpl;

import java.util.Iterator;
import java.util.List;
import java.util.LinkedList;

public class DiningRoom extends NonBlockingBladeBase {
	public DiningRoom() throws Exception {
	}

    /*
        The dining room implements a feast request, which creates the dining table and 
        the philosophers and sends a feast request to all the philosophers. The result 
        returned is a list of the number of meals eaten by each philosopher.
    */
    public AOp&lt;List&lt;Integer&gt;&gt; feastAOp(final int _seats, final int _meals) {
        return new AOp&lt;List&lt;Integer&gt;&gt;("feast", getReactor()) {
            List&lt;Integer&gt; mealsEaten = new LinkedList&lt;Integer&gt;(); //The list passed back when the feast is done.
            
            /*
                Start the feast.
            */
            @Override
            protected void processAsyncOperation(final AsyncRequestImpl _asyncRequestImpl, 
					final AsyncResponseProcessor&lt;List&lt;Integer&gt;&gt; _asyncResponseProcessor) throws Exception {

                /*
                    Processes the response from a philosopher when he is done feasting.
                */
				AsyncResponseProcessor&lt;Integer&gt; feastResponseProcessor =
						new AsyncResponseProcessor&lt;Integer&gt;() {
					@Override
					public void processAsyncResponse(final Integer _feastResponse) throws Exception {
						mealsEaten.add(_feastResponse);
						if (mealsEaten.size() == _seats) { //This is the response from the last philosopher.
							_asyncResponseProcessor.processAsyncResponse(mealsEaten);
						}
					}
				};
            
                int i = 0;
                final DiningTable diningTable = new DiningTable(
                    _seats,
                    _meals);
                while (i &lt; _seats) {
                    DiningPhilosopher diningPhilosopher =
                        new DiningPhilosopher();
                    AOp&lt;Integer&gt; feastAReq = diningPhilosopher.feastAOp(diningTable, i);
                    _asyncRequestImpl.send(feastAReq, feastResponseProcessor);
                    ++i;
                }
            }
        };
    }
    
    public static void main(String[] args) throws Exception {
        int seats = 5;
        int meals = 1000000;
        new Plant();
        try {
            DiningRoom diningRoom = new DiningRoom();
            AOp&lt;List&lt;Integer&gt;&gt; feastAOp = diningRoom.feastAOp(seats, meals);
            long before = System.nanoTime();
            List&lt;Integer&gt; mealsEaten = feastAOp.call(); //Run the feast.
            long after = System.nanoTime();
            long duration = after - before;
            System.out.println("Seats: " + seats);
            System.out.println("Meals: " + meals);
            System.out.println("\nMeals eaten by each philosopher:");
            Iterator&lt;Integer&gt; it = mealsEaten.iterator();
            int totalEaten = 0;
            while (it.hasNext()) {
                int me = it.next();
                totalEaten += me;
                if (mealsEaten.size() &lt; 11)
                    System.out.println("    " + me);
            }
            if (totalEaten != meals)
                throw new IllegalStateException("total meals eaten does not match: " + totalEaten);
            System.out.println("\nTest duration in nanoseconds: " + duration);
            if (duration > 0) {
                System.out.println("Total meals eaten per second: " + (1000000000L * meals / duration));
            }
        } finally {
            Plant.close();
        }
    }
}
</pre>
<h3>Performance</h3>
<pre>
Output:

Seats: 5
Meals: 1,000,000

Meals eaten by each philosopher:
    192368
    167389
    294981
    151082
    194180

Test duration in nanoseconds: 3410205190
Total meals eaten per second: 293237
</pre>
</body>
</html>
