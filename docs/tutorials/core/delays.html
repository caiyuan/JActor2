<html>
<title>Scalable Timers</title>
</head>
<body>
<p>
<a href="https://github.com/laforge49/JActor2#readme">JActor2</a> &gt; <a href="../../index.html">Docs</a> &gt; <a href="../index.html">Tutorials</a> &gt; <a href="index.html">Core</a> &gt; Delays
</p>
<h1>Delays - Scalable Timers</h1>
<p>
Using sleep to create a delay is fine for simulating I/O, but it blocks the thread.
So it does not scale very well when you need a lot of timers.
<a href="../../api/core/org/agilewiki/jactor2/core/plant/DelayAOp.html">DelayAOp</a>,
on the other hand, is a light-weight operation that scales nicely, as it uses the
<a href="../../api/core/org/agilewiki/jactor2/core/plant/PlantScheduler.html#schedule-java.lang.Runnable-int-">schedule</a>
method in PlantScheduler.
The <a href="java7/Delays.java">Delays</a> program demonstrates the scalability of DelayAOp by running 10,000 timers in parallel.
</p>
<pre>
import org.agilewiki.jactor2.core.blades.NonBlockingBladeBase;
import org.agilewiki.jactor2.core.plant.DelayAOp;
import org.agilewiki.jactor2.core.impl.Plant;
import org.agilewiki.jactor2.core.requests.AOp;
import org.agilewiki.jactor2.core.requests.AsyncResponseProcessor;
import org.agilewiki.jactor2.core.requests.impl.AsyncRequestImpl;

public class Delays extends NonBlockingBladeBase {
    private final long count;

    Delays(final long _count) throws Exception {
        count = _count;
    }

    public AOp&lt;Void&gt; runAOp() {
        return new AOp&lt;Void&gt;("run", getReactor()) {
            protected void processAsyncOperation(final AsyncRequestImpl _asyncRequestImpl, 
					final AsyncResponseProcessor&lt;Void&gt; _asyncResponseProcessor) throws Exception {
				final AsyncResponseProcessor&lt;Void&gt; delayResponseProcessor =
						new AsyncResponseProcessor&lt;Void&gt;() {
                    @Override
                    public void processAsyncResponse(final Void _response) throws Exception {
                        if (_asyncRequestImpl.getPendingResponseCount() == 0)
                            _asyncResponseProcessor.processAsyncResponse(null);
                    }
                };

                long j = 0;
                while(j &lt; count) {
                    j++;
                    DelayAOp delay = new DelayAOp(100);
                    _asyncRequestImpl.send(delay, delayResponseProcessor);
                }
            }
        };
    }

    public static void main(final String[] _args) throws Exception {
        final long count = 10000L;
        new Plant(10);
        try {
            Delays delays = new Delays(count);
            AOp&lt;Void&gt; runAOp = delays.runAOp();
            final long before = System.currentTimeMillis();
            runAOp.call();
            final long after = System.currentTimeMillis();
            final long duration = after - before;
            System.out.println("Delay Test with " + count + " delays run in parallel");
            System.out.println("delay duration: 100 milliseconds each");
            System.out.println("total time: " + duration + " milliseconds");
        } finally {
            Plant.close();
        }
    }
}

    Output:
    
Delay Test with 10000 delays run in parallel
delay duration: 100 milliseconds each
total time: 304 milliseconds
</pre>
</body>
</html>
