<html>
<body>
<p>
<a href="https://github.com/laforge49/JActor2#readme">JActor2</a> &gt; <a href="../../index.html">Docs</a> &gt; <a href="../index.html">Tutorials</a> &gt; <a href="index.html">Core</a> &gt; Ponger
</p>
<h1>Ponger - SyncRequest</h1>
<p>
JActor is a framework for ensuring thread safety without locks.
JActor supports the use of multiple
<a href="../../api/org/agilewiki/jactor2/core/reactors/Reactor.html">Reactor</a>s
which serve as light-weight threads.
Each reactor, in turn, can have any number of
<a href="../../api/org/agilewiki/jactor2/core/blades/Blade.html">Blade</a>s,
with each blade having some state that is accessed in a thread-safe way via one or more
<a href="../../api/org/agilewiki/jactor2/core/requests/Request.html">Request</a>s.
</p>
<p>
There are 5 types of reactors:
<a href="../../api/org/agilewiki/jactor2/core/reactors/BlockingReactor.html">BlockingReactor</a>,
<a href="../../api/org/agilewiki/jactor2/core/reactors/IsolationReactor.html">IsolationReactor</a>,
<a href="../../api/org/agilewiki/jactor2/core/reactors/NonBlockingReactor.html">NonBlockingReactor</a>,
<a href="../../api/org/agilewiki/jactor2/core/reactors/SwingBoundReactor.html">SwingBoundReactor</a> and
<a href="../../api/org/agilewiki/jactor2/core/reactors/ThreadBoundReactor.html">ThreadBoundReactor</a>.
The most common type of reactor is the NonBlockingReactor, which will be our starting point.
Non-blocking reactors operate under the assumption that they will not block threads, through locking, I/O
or long computations.
</p>
<p>
Most blades are specialized and will work with only one type of reactor.
<a href="../../api/org/agilewiki/jactor2/core/blades/NonBlockingBlade.html">NonBlockingBlade</a>,
for example, is a type of blade that only works with a NonBlockingReactor. And
<a href="../../api/org/agilewiki/jactor2/core/blades/NonBlockingBladeBase.html">NonBlockingBladeBase</a>
is a convenience class used to implement a non-blocking blade.
</p>
<p>
There are two types of requests:
<a href="../../api/org/agilewiki/jactor2/core/requests/SyncRequest.html">SyncRequest</a>s and
<a href="../../api/org/agilewiki/jactor2/core/requests/AsyncRequest.html">AsyncRequest</a>s.
But for now we will focus on syncronous requests, which are a lock-free alternative to Java's synchronized.
</p>
<p>
Our first example is 
<a href="java7/Ponger.java">Ponger</a>,
a non-blocking blade with a synchronous request, pingSReq.
This request returns the number of times it has been invoked:
<pre>
import org.agilewiki.jactor2.core.blades.NonBlockingBladeBase;
import org.agilewiki.jactor2.core.requests.SyncRequest;
import org.agilewiki.jactor2.core.reactors.NonBlockingReactor;

public class Ponger extends NonBlockingBladeBase {
    private long count = 0;
    
    public Ponger(final NonBlockingReactor _reactor) throws Exception {
        initialize(_reactor);
    }

    public SyncRequest&lt;Long&gt; pingSReq() {
        return new SyncBladeRequest&lt;Long&gt;() {
            @Override
            public Long processSyncRequest() throws Exception {
                count += 1;
                return count;
            }
        };
    }
}
</pre>
<h3>
Thread Safety
</h3>
<pre>
    private long count = 0;
</pre>
<p>
The member variable count is private and the only means of updating it is through a
request. Which makes it thread-safe.
</p>
<h3>
<a href="../../api/org/agilewiki/jactor2/core/blades/NonBlockingBladeBase.html#initialize-org.agilewiki.jactor2.core.reactors.NonBlockingReactor-">initialize</a>
</h3>
<pre>
    public Ponger(final NonBlockingReactor _reactor) throws Exception {
        initialize(_reactor);
    }
</pre>
<p>
Every blade needs a reactor before it can send or receive messages.
And once set, a blade can not be assigned a different reactor.
Reactors serve both as message queues and as light-weight threads.
</p>
<h3>
<a href="../../api/org/agilewiki/jactor2/core/blades/BladeBase.SyncBladeRequest.html">SyncBladeRequest</a>
</h3>
<pre>
    public SyncRequest&lt;Long&gt; pingSReq() {
        return new SyncBladeRequest&lt;Long&gt;() {
            ...
        };
    }
</pre>
<p>
SyncBladeRequest is a BladeBase nested class that extends SyncRequest.
The pingSReq method returns a non-reusable instance of a SyncRequest for accessing the state of the blade.
</p>
<h3>
<a href="../../api/org/agilewiki/jactor2/core/messages/SyncRequest.html#processSyncRequest--">processSyncRequest</a>
</h3>
<pre>
            @Override
            public Long processSyncRequest() throws Exception {
                count += 1;
                return count;
            }
</pre>
<p>
The processSyncRequest method is called when the SyncRequest is invoked.
But it runs on the thread of the reactor assigned to the blade,
regardless of which thread was used to invoke the SyncRequest.
This method is used to access and/or update the state of the blade and to return a result.
</p>
<h2>
<a href="java7/PongerTest.java">PongerTest</a>
</h2>
<p>
PongerTest is a simple program that exercises Ponger:
</p>
<pre>
import org.agilewiki.jactor2.core.facilities.Plant;
import org.agilewiki.jactor2.core.reactors.NonBlockingReactor;

public class PongerValidator {
    public static void main(final String[] _args) throws Exception {
        new Plant();
        try {
            Ponger ponger = new Ponger(new NonBlockingReactor());
            long j = ponger.pingSReq().call();
            if (1 != j)
                throw new IllegalStateException("unexpected result");
        } finally {
            plant.close();
        }
    }
}
</pre>
<table style="border: 2px solid;" bgcolor="lightgray">
<tr>
<th style="padding: 5px;" bgcolor="lightyellow">
Main Thread
</th>
<th>
&nbsp;
</th>
<th style="padding: 5px;" bgcolor="lightyellow">
Non-Blocking Reactor
</th>
</tr>
<tr>
<th style="padding: 5px;" bgcolor="lightyellow">
PongerTest
</th>
<th>
&nbsp;
</th>
<th style="padding: 5px;" bgcolor="lightyellow">
Ponger
</th>
</tr>
<tr>
<td style="border: 1px solid; padding: 5px;" bgcolor="lightyellow">
create Plant
</td>
<td style="padding: 5px;">
&nbsp;
</td>
<td>
&nbsp;
</td>
</tr>
<tr>
<tr>
<td style="border: 1px solid; padding: 5px;" bgcolor="lightyellow">
create Ponger
</td>
<td style="padding: 5px;">
&nbsp;
</td>
<td>
&nbsp;
</td>
</tr>
<tr>
<td style="border: 1px solid; padding: 5px;" bgcolor="lightyellow">
call
</td>
<td style="padding: 5px;">
&nbsp;
</td>
<td>
&nbsp;
</td>
</tr>
<tr>
<td style="border: 1px solid; padding: 5px;" bgcolor="lightyellow">
wait
</td>
<td style="padding: 5px; text-align: center;">
---ping-->
</td>
<td style="border: 1px solid; padding: 5px;" bgcolor="lightyellow">
allocate thread
</td>
</tr>
<tr>
<td style="padding: 5px;">
&nbsp;
</td>
<td style="padding: 5px;">
&nbsp;
</td>
<td style="border: 1px solid; padding: 5px;" bgcolor="lightyellow">
count += 1
</td>
</tr>
<tr>
<td style="border: 1px solid; padding: 5px;" bgcolor="lightyellow">
wakeup
</td>
<td style="padding: 5px; text-align: center;">
<--response: count---
</td>
<td style="border: 1px solid; padding: 5px;" bgcolor="lightyellow">
release thread
</td>
</tr>
<tr>
<td style="border: 1px solid; padding: 5px;" bgcolor="lightyellow">
validate response
</td>
<td style="padding: 5px;">
&nbsp;
</td>
<td style="padding: 5px;">
&nbsp;
</td>
</tr>
<tr>
<td style="border: 1px solid; padding: 5px;" bgcolor="lightyellow">
close Plant
</td>
<td style="padding: 5px;">
&nbsp;
</td>
<td style="padding: 5px;">
&nbsp;
</td>
</tr>
</table>
<h3>
<a href="../../api/org/agilewiki/jactor2/core/plant/Plant.html">Plant</a>
</h3>
<pre>
        new Plant();
        try {
            ...
        } finally {
            Plant.close();
        }
</pre>
<p>
Every program must have a Plant, which provides a threadpool for the reactors to use.
A program will not normally exit until either
<a href="../../api/org/agilewiki/jactor2/core/plant/Plant.html#close--">Plant.close</a> or
<a href="../../api/org/agilewiki/jactor2/core/plant/Plant.html#exit--">Plant.exit</a>
is called.
</p>
<h3>
<a href="../../api/org/agilewiki/jactor2/core/requests/Request.html#call--">call</a>
</h3>
<pre>
            long j = ponger.pingSReq().call();
            if (1 != j)
                throw new IllegalStateException("unexpected result");
</pre>
<p>
The call method will return the result from invoking a request, but can not be used from within a blade.
This method blocks the main thread until a result is received.
</p>
</body>
</html>
