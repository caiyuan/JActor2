<html>
<body>
<p>
<a href="https://github.com/laforge49/JActor2#readme">JActor2</a> &gt; <a href="../../index.html">Docs</a> &gt; <a href="../index.html">Tutorials</a> &gt; <a href="index.html">Core</a> &gt; Ponger
</p>
<h1>Ponger - SyncRequest</h1>
<a href="Ponger.java">Ponger</a>
is a very simple blade. It has a synchronous request, pingSReq.
This request returns the number of times it has been called:
<pre>
import org.agilewiki.jactor2.core.blades.NonBlockingBladeBase;
import org.agilewiki.jactor2.core.messages.SyncRequest;
import org.agilewiki.jactor2.core.reactors.NonBlockingReactor;

public class Ponger extends NonBlockingBladeBase {
    private long count = 0;
    
    public Ponger(final NonBlockingReactor _reactor) throws Exception {
        initialize(_reactor);
    }

    public SyncRequest&lt;Long&gt; pingSReq() {
        return new SyncBladeRequest&lt;Long&gt;() {
            @Override
            public Long processSyncRequest() throws Exception {
                count += 1;
                return count;
            }
        };
    }
}
</pre>
<h3>
<a href="../../api/org/agilewiki/jactor2/core/blades/NonBlockingBladeBase.html">NonBlockingBladeBase</a>
</h3>
<pre>
public class Ponger extends NonBlockingBladeBase {
    ...
}
</pre>
<p>
NonBlockingBladeBase implements the 
<a href="../../api/org/agilewiki/jactor2/core/blades/NonBlockingBlade.html">NonBlockingBlade</a>
interface and provides a number of methods and nested
classes for use when implementing a 
<a href="../../api/org/agilewiki/jactor2/core/blades/Blade.html">Blade</a>
which does not block its thread.
</p>
<h3>
Thread Safety
</h3>
<pre>
    private long count = 0;
</pre>
<p>
The member variable count is private and the only means of updating it is through a
request. Which makes it thread-safe.
</p>
<h3>
<a href="../../api/org/agilewiki/jactor2/core/blades/NonBlockingBladeBase.html#initialize-org.agilewiki.jactor2.core.reactors.NonBlockingReactor-">NonBlockingBladeBase.initialize</a>
</h3>
<pre>
    public Ponger(final NonBlockingReactor _reactor) throws Exception {
        initialize(_reactor);
    }
</pre>
<p>
Every blade needs a reactor before it can send or receive messages.
And once set, a blade can not be assigned a different reactor.
Reactors serve both as message queues and as light-weight threads.
And 
<a href="../../api/org/agilewiki/jactor2/core/reactors/NonBlockingReactor.html">NonBlockingReactor</a>
is optimized for blades which do not block their thread.
</p>
<h3>
<a href="../../api/org/agilewiki/jactor2/core/blades/BladeBase.SyncBladeRequest.html">SyncBladeRequest&lt;RESPONSE_TYPE&gt;</a>
</h3>
<pre>
    public SyncRequest&lt;Long&gt; pingSReq() {
        return new SyncBladeRequest&lt;Long&gt;() {
            ...
        };
    }
</pre>
<p>
SyncBladeRequest is a BladeBase nested class that extends
<a href="../../api/org/agilewiki/jactor2/core/messages/SyncRequest.html">SyncRequest&lt;RESPONSE_TYPE&gt;</a>.
The pingSReq method returns a non-reusable instance of SyncRequest for accessing the state of the blade.
</p>
<h3>
<a href="../../api/org/agilewiki/jactor2/core/messages/SyncRequest.html#processSyncRequest--">SyncRequest.processSyncRequest</a>
</h3>
<pre>
            @Override
            public Long processSyncRequest() throws Exception {
                count += 1;
                return count;
            }
</pre>
<p>
The processSyncRequest method is called when the SyncRequest is invoked.
But it runs on the thread of the reactor assigned to the blade,
regardless of which thread was used to invoke the SyncRequest.
This method is used to access and/or update the state of the blade and to return a result.
</p>
<h2>
<a href="PongerValidator.java">PongerValidator</a>
</h2>
<p>
PongerValidator is a simple program that exercises Ponger:
</p>
<pre>
import org.agilewiki.jactor2.core.facilities.BasicPlant;
import org.agilewiki.jactor2.core.facilities.Plant;
import org.agilewiki.jactor2.core.reactors.NonBlockingReactor;

public class PongerValidator {
    public static void main(final String[] _args) throws Exception {
        BasicPlant plant = new Plant();
        try {
            Ponger ponger = new Ponger(new NonBlockingReactor());
            long i = 0;
            while (i < 10) {
                i++;
                long j = ponger.pingSReq().call();
                if (i != j)
                    throw new IllegalStateException("unexpected result");
            }
        } finally {
            plant.close();
        }
    }
}
</pre>
<h3>
<a href="../../api/org/agilewiki/jactor2/core/reactors/NonBlockingReactor.html">NonBlockingReactor</a>
</h3>
<pre>
            Ponger ponger = new Ponger(new NonBlockingReactor());
</pre>
<p>
Blades generally use non-blocking reactors, but only if they do not block the thread for I/O, intense computation 
or any other reason.
</p>
<h3>
<a href="../../api/org/agilewiki/jactor2/core/messages/RequestBase.html#call()">call</a>
</h3>
<pre>
            long i = 0;
            while (i < 10) {
                i++;
                long j = ponger.pingSReq().call();
                if (i != j)
                    throw new IllegalStateException("unexpected result");
            }
</pre>
<p>
The call method will return the result from invoking a request, but can not be used from within a blade.
This method blocks the main thread until a result is received.
</p>
</body>
</html>
