<html>
<head> <title>SOp</title>
</head>
<body>
<p>
<a href="https://github.com/laforge49/JActor2#readme">JActor2</a> &gt; <a href="../../index.html">Docs</a> &gt; <a href="../index.html">Tutorials</a> &gt; <a href="index.html">Core</a> &gt; Ponger
</p>
<h1>Ponger - SOp</h1>
<p>
JActor is a framework for ensuring thread safety without locks.
JActor supports the use of multiple
<a href="../../api/core/org/agilewiki/jactor2/core/reactors/Reactor.html">Reactor</a>s
which serve as light-weight threads, and which are sometimes called 
<a href="http://en.wikipedia.org/wiki/Fiber_(computer_science)">fibers</a> or 
<a href="http://en.wikipedia.org/wiki/E_(programming_language)">vats</a>.
(JActor actually uses a 
<a href="http://en.wikipedia.org/wiki/Thread_(computer_science)#Models">M:N threading model</a>.)
Each reactor, in turn, can have any number of
<a href="../../api/core/org/agilewiki/jactor2/core/blades/Blade.html">Blade</a>s,
with each blade having some state that is accessed in a thread-safe way via one or more
synchronous or asynchronous operations.
</p>
<p>
There are 5 types of reactors:
<a href="../../api/core/org/agilewiki/jactor2/core/reactors/BlockingReactor.html">BlockingReactor</a>,
<a href="../../api/core/org/agilewiki/jactor2/core/reactors/IsolationReactor.html">IsolationReactor</a>,
<a href="../../api/core/org/agilewiki/jactor2/core/reactors/NonBlockingReactor.html">NonBlockingReactor</a>,
<a href="../../api/core/org/agilewiki/jactor2/core/reactors/SwingBoundReactor.html">SwingBoundReactor</a> and
<a href="../../api/core/org/agilewiki/jactor2/core/reactors/ThreadBoundReactor.html">ThreadBoundReactor</a>.
The most common type of reactor is the NonBlockingReactor, which will be our starting point.
Non-blocking reactors operate under the assumption that they will not block threads, through locking, I/O
or long computations.
</p>
<p>
Most blades are specialized and will work with only one type of reactor.
<a href="../../api/core/org/agilewiki/jactor2/core/blades/NonBlockingBlade.html">NonBlockingBlade</a>,
for example, is a type of blade that only works with a NonBlockingReactor. And
<a href="../../api/core/org/agilewiki/jactor2/core/blades/NonBlockingBladeBase.html">NonBlockingBladeBase</a>
is a convenience class used to implement a non-blocking blade.
Multiple blades can share the same reactor, which introduces an aspect of composition. Such blades
can safely access each other's state either directly or via simple methods.
</p>
<p>
There are two types of operations:
<a href="../../api/core/org/agilewiki/jactor2/core/requests/SOp.html">SOp</a> and
<a href="../../api/core/org/agilewiki/jactor2/core/requests/AOp.html">AOp</a>.
But for now we will focus mostly on SOp, which supports synchronous operations. 
SOp is a lock-free alternative to Java's synchronized.
</p>
<p>
Our first example is 
<a href="java7/Ponger.java">Ponger</a>,
a blade with a synchronous operation, pingSOp.
This operation returns the number of times it has been invoked:
<pre>
import org.agilewiki.jactor2.core.blades.BladeBase;
import org.agilewiki.jactor2.core.requests.SOp;
import org.agilewiki.jactor2.core.reactors.NonBlockingReactor;
import org.agilewiki.jactor2.core.reactors.Reactor;
import org.agilewiki.jactor2.core.requests.impl.RequestImpl;

public class Ponger extends BladeBase {
    private long count = 0;
    
    public Ponger() throws Exception {
        _initialize(new NonBlockingReactor());
    }
    
    public Ponger(final Reactor _reactor) {
        _initialize(_reactor);
    }

    public SOp&lt;Long&gt; pingSOp() {
        return new SOp("ping", getReactor()) {
            @Override
            public Long processSyncOperation(final RequestImpl _requestImpl) {
				count += 1;
				return count;
            }
        };
    }
}
</pre>
<h3>
Thread Safety
</h3>
<pre>
    private long count = 0;
</pre>
<p>
The member variable count is private and the only means of updating it are through an
operation, which makes it thread-safe as long as the processSyncOperation is not called directly.
</p>
<h3>
The Reactor
</h3>
<pre>
    public Ponger() {
        _initialize(new NonBlockingReactor();
    }
    
    public Ponger(final Reactor _reactor) {
        _initialize(_reactor);
    }
</pre>
<p>
Every blade needs a reactor before it can send or receive messages.
Reactors serve both as incoming queues, outgoing message buffers and as light-weight threads.
</p>
<p>
The default constructor creates a NonBlockingReactor. So you can either
specify a particular reactor, which is useful when sharing reactors between blades, or have a new
reactor created by default.
</p>
<h3>
<a href="../../api/core/org/agilewiki/jactor2/core/requests/SOp.html">SOp</a>
</h3>
<pre>
    public SOp&lt;Long&gt; pingSOp() {
        return new SOp("ping", getReactor()) {
            ...
        };
    }
</pre>
<p>
The pingSOp method returns a reusable instance of a SOp for accessing the state of the blade.
Once the caller of the pingSOp method has a SOp there are several different ways to invoke the operation,
as we will see later.
</p>
<p>
The arguments of the SOp constructor are (1) the name of the request and (2) the reactor used by the blade.
The getReactor method is implemented by all blades.
</p>
<h3>
<a href="../../api/core/org/agilewiki/jactor2/core/requests/SyncOperation.html#processSyncOperation-org.agilewiki.jactor2.core.requests.impl.RequestImpl-">processSyncOperation</a>
</h3>
<pre>
            @Override
            public Long processSyncRequest() {
                return ping();
            }
</pre>
<p>
The processSyncOperation method is called when the SOp is invoked.
It always runs on the thread of the reactor assigned to the blade,
regardless of which thread was used to invoke the SOp, making it thread safe.
</p>
<h2>
<a href="java7/PongerTest.java">PongerTest</a>
</h2>
<p>
PongerTest is a simple program that exercises Ponger:
</p>
<pre>
import org.agilewiki.jactor2.core.impl.Plant;
import org.agilewiki.jactor2.core.reactors.NonBlockingReactor;

public class PongerTest {
    public static void main(final String[] _args) throws Exception {
        new Plant();
        try {
            Ponger ponger = new Ponger();
            long j = ponger.pingSOp().call();
            if (1 != j)
                throw new IllegalStateException("unexpected result");
        } finally {
            Plant.close();
        }
    }
}
</pre>
<table style="border: 2px solid;" bgcolor="lightgray">
<tr>
<th style="padding: 5px;" bgcolor="lightyellow">
Main Thread
</th>
<th>&nbsp;

</th>
<th style="padding: 5px;" bgcolor="lightyellow">
Non-Blocking Reactor
</th>
</tr>
<tr>
<th style="padding: 5px;" bgcolor="lightyellow">
PongerTest
</th>
<th>&nbsp;

</th>
<th style="padding: 5px;" bgcolor="lightyellow">
Ponger
</th>
</tr>
<tr>
<td style="border: 1px solid; padding: 5px;" bgcolor="lightyellow">
create Plant
</td>
<td style="padding: 5px;">&nbsp;

</td>
<td>&nbsp;

</td>
</tr>
<tr>
<tr>
<td style="border: 1px solid; padding: 5px;" bgcolor="lightyellow">
create Ponger
</td>
<td style="padding: 5px;">&nbsp;

</td>
<td>&nbsp;

</td>
</tr>
<tr>
<td style="border: 1px solid; padding: 5px;" bgcolor="lightyellow">
call
</td>
<td style="padding: 5px;">&nbsp;

</td>
<td>&nbsp;

</td>
</tr>
<tr>
<td style="border: 1px solid; padding: 5px;" bgcolor="lightyellow">
wait
</td>
<td style="padding: 5px; text-align: center;">
---ping-->
</td>
<td style="border: 1px solid; padding: 5px;" bgcolor="lightyellow">
allocate thread
</td>
</tr>
<tr>
<td style="padding: 5px;">&nbsp;

</td>
<td style="padding: 5px;">&nbsp;

</td>
<td style="border: 1px solid; padding: 5px;" bgcolor="lightyellow">
count += 1
</td>
</tr>
<tr>
<td style="border: 1px solid; padding: 5px;" bgcolor="lightyellow">
wakeup
</td>
<td style="padding: 5px; text-align: center;">
<--response: count---
</td>
<td style="border: 1px solid; padding: 5px;" bgcolor="lightyellow">
release thread
</td>
</tr>
<tr>
<td style="border: 1px solid; padding: 5px;" bgcolor="lightyellow">
validate response
</td>
<td style="padding: 5px;">&nbsp;

</td>
<td style="padding: 5px;">&nbsp;

</td>
</tr>
<tr>
<td style="border: 1px solid; padding: 5px;" bgcolor="lightyellow">
close Plant
</td>
<td style="padding: 5px;">&nbsp;

</td>
<td style="padding: 5px;">&nbsp;

</td>
</tr>
</table>
<h3>
<a href="../../api/coreMt/org/agilewiki/jactor2/core/impl/Plant.html">Plant</a>
</h3>
<pre>
        new Plant();
        try {
            ...
        } finally {
            Plant.close();
        }
</pre>
<p>
Every program must have a Plant, which provides a threadpool for the reactors to use.
But a program will not normally exit until the threadpool is closed. This is done when
<a href="../../api/core/org/agilewiki/jactor2/core/plant/PlantBase.html#close--">Plant.close</a>
is called.
</p>
<p>
Plant must be created explicitly, though many of its methods are static. 
This allows you to change the size of the thread pool, the recovery logic, and many other aspects
by using an alternate constructor.
</p>
<h3>
<a href="../../api/core/org/agilewiki/jactor2/core/requests/Request.html#call--">call</a>
</h3>
<pre>
            long j = ponger.pingSOp().call();
            if (1 != j)
                throw new IllegalStateException("unexpected result");
</pre>
<p>
The call method is one of three ways of invoking a SOp,
but <strong>call can not be used from within an operation.</strong>
The call method blocks the main thread until it can return the result passed back from the invoked operation.
</p>
</body>
</html>
