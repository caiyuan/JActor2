<html>
<title>One-way Messages</title>
</head>
<body>
<p>
<a href="https://github.com/laforge49/JActor2#readme">JActor2</a> &gt; <a href="../../index.html">Docs</a> &gt; <a href="../index.html">Tutorials</a> &gt; <a href="index.html">Core</a> &gt; Signals
</p>
<h1>Signals - One-way Messages</h1>
<p>
In addition to using call, syncDirect and send, 
the signal method can be used to pass a request to its target blade for processing.
Using signals means:
</p>
<ul>
<li>
Like syncDirect and send, signal does not block any thread.
</li>
<li>
Unlike call, syncDirect and send, signal can be used from any thread.
</li>
<li>
Like call and syncDirect, signal messages are unbuffered--they are sent immediately.
</li>
<li>
Unlike call and send, there is no response passed back from the request passed as a signal.
And if an exception is thrown and uncaught while processing the request, it is logged rather than being
passed back to the source of the request.
</li>
</ul>
<p>
Strange things tend to happen when you overuse signals, as it is easy to fill memory with signals awaiting processing.
This slows garbage collection and my start the program paging to disk.
Signals are supported because there are situations when they are invaluable. But their use is
not entirely risk free.
</p>
<p>
The <a href="java7/Signals.java">Signals</a> program illustrates the use of signals. 
</p>
<pre>
import org.agilewiki.jactor2.core.blades.NonBlockingBladeBase;
import org.agilewiki.jactor2.core.impl.Plant;
import org.agilewiki.jactor2.core.requests.SOp;
import org.agilewiki.jactor2.core.requests.impl.RequestImpl;

public class Signals extends NonBlockingBladeBase {

	public Signals() throws Exception {
	}
    
    public static void main(final String[] _args) throws Exception {
        new Plant();
        try {
            Signals signals = new Signals();
            int i = 0;
            while (i &lt; 10) {
                i++;
                signals.printSOp(i).signal();
            }
            signals.getReactor().nullSOp().call();
        } finally {
            Plant.close();
        }
    }
        
    SOp&lt;Void&gt; printSOp(final Integer _i) {
        return new SOp&lt;Void&gt;("print", getReactor()) {
            @Override
            public Void processSyncOperation(final RequestImpl _requestImpl) throws Exception {
                System.out.println(_i);
                return null;
            }
        };
    }
}

Output:

Count to 10

1
2
3
4
5
6
7
8
9
10
</pre>
</body>
</html>
