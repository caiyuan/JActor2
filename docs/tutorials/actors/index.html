<html>
<head>
<title>
Modelling Actors with Locks
</title>
</head>
<body>
<p>
<a href="https://github.com/laforge49/JActor2#readme">JActor2</a> &gt; <a href="../../index.html">Docs</a> &gt; <a href="../index.html">Tutorials</a> &gt; Modelling Actors
</p>
<p>
It appears that too many developers do not understand actors, and that actors have not been explained very well.
My thought is that a model that behaves, to a degree, like actors might go a long way to explaining actors through analogy,
especially if that model can be implemented with a minimum of code. Mind, the model is only an approximation.
But even so, you may find it interesting/informative.
</p>
<h2>
Asynchronous Methods
</h2>
<p>
Asynchronous methods will serve as models for the asynchronous message processing of actors.
What this means is that return values will be passed via a callback.
The Reply interface defines these callbacks:
</p>
<pre>
    interface Reply<RESPONSE_TYPE> {
        void response(RESPONSE_TYPE _value);
    }
</pre>
<p>
Asynchronous methods will always have Reply as their first argument,
and the returned value is passed back to the caller by calling the response method,
though not always on the same thread.
</p>
<h2>
A Trivial Application
</h2>
<p>
Our application has two objects, instances of class A and B, and a class M which has a main method.
The main method creates these two instance and calls a method on the instance of A, which in turn calls a method on
the instance of B. Responses are then passed back with callbacks.
</p>
<pre>
    public class M {
        public static void main(String[] args) {
            Reply<Void> reply = new Reply<Void>() {
                @Override
                public void response(Void value) {
                    System.out.println("end");
                }
            };
            new A().begin(reply, new B());
        }
    }

    class A implements Reply<Void> {
        private Reply<Void> externalReply;
    
        void begin(Reply<Void> _externalReply, B _b) {
            externalReply = _externalReply;
            _b.add1(this);
        }
    
        @Override
        public void response(Void value) {
            System.out.println("added 1");
            externalReply.response(null);
        }
    }

    class B {
        private int count;
    
        void add1(Reply<Void> _reply) {
            count += 1;
            _reply.response(null);
        }
    }

    Output:

    added 1
    end
</pre>
<p>
Note that method B.add1 is entirely synchronous, so the reply is done on the same thread that calls this method.
This is not a limitation of the model, as asynchronous I/O is allowed.
Blocking the thread, on the other hand, is not allowed.
</p>
<p>
Now there are two points where this code is not thread-safe. First, the statement <strong>count += 1</strong>
in the B.add1 method.
The second point is the use of the <strong>externalReply</strong> variable in class A is not thread safe.
</p>
<h2>
Basic Actor Model
</h2>
<p>
Actors do something very nice. They process messages (requests/responses) one at a time. This nicely prevents most,
but not all, race conditions from occurring. The key thing here is that an actor can continue to process messages
when it is not actively processing another message, rather than blocking until it gets a response. So there is no
risk of deadlocks. This constraint is also easy to model:
</p>
<pre>
    class B {
        private int count;
    
        void add1(Reply<Void> _reply) {
            synchronized(this) {
                count += 1;
            }
            _reply.response(null);
        }
    }
</pre>
<p>
We have wrapped the <strong>count += 1</strong> statement in a synchronized lock to emulate an actor's one message at a time
constraint, eliminating a rather subtle race condition that would be difficult to expose through testing as it will rarely occur
even with many threads calling the add1 method in parallel.
And as long as the scope of the lock remains confined to a single object, there is no risk of deadlocks.
There is no doubt that the processing of one message at a time by actors is an unqualified goodness.
</p>
<p>
What remains then is the unsafe usage of the <strong>externalReply</strong> variable in class A. On the plus side,
this potential race condition is not too difficult to spot and may even show up in testing. But fixing problems like this
in the application logic can easily lead to
<a href="http://www.infoq.com/presentations/Death-by-Accidental-Complexity">Death by Accidental Complexity</a>.
So there is strong motivation for actors to provide some facility that makes it easy to address this.
</p>
<p>
The problem with the externalReply variable is generally characterized as the the difficulty of handling streams of messages
from multiple sources. The number of possible orderings of these messages grows very rapidly as the number of sources increases.
In the case of class A, the problem arises when a second call is made to the begin method before the first call has completed.
An obvious solution then is to add some constraints to block some methods from executing while the application logic is busy
doing something else.
</p>
<h2>
Guard Actor Model
</h2>
<p>
Actors are generally implemented as guard actors, meaning that they guard the application from messages they are not prepared 
to handle in their current state. But for our simplistic application, we really only have two states that are critical: either the 
application is expecting a response or it is not. If the application is expecting a response, it will not immediately process
another request. And conversely, if no response is expected then something is wrong. This keeps our emulation logic simple.
</p>
<pre>
    import java.util.concurrent.atomic.AtomicBoolean;

    class GuardActor {
        private AtomicBoolean busy = new AtomicBoolean();
        private volatile boolean replyExpected;
    
        protected void start(boolean isReply) {
            while (true) {
                while ((replyExpected && !isReply) || !busy.compareAndSet(false, true))
                    Thread.yield();
                if (!replyExpected && isReply) {
                    busy.set(false);
                    throw new UnsupportedOperationException("Reply received when none expected");
                }
                if (replyExpected == isReply)
                    return;
                busy.set(false);
                Thread.yield();
            }
        }
    
        protected void finish(boolean expectingReply) {
            replyExpected = expectingReply;
            busy.set(false);
        }
    }
</pre>
<p>
Now we replace synchronized with start/finish. But we also need to wrap all the logic of all the application methods:
</p>
<pre>
    class A extends GuardActor implements Reply<Void> {
        private Reply<Void> externalReply;
    
        void begin(Reply<Void> _externalReply, B _b) {
            start(false);
            externalReply = _externalReply;
            finish(true);
            _b.add1(this);
        }
    
        @Override
        public void response(Void value) {
            start(true);
            System.out.println("added 1");
            finish(false);
            externalReply.response(null);
        }
    }

    class B extends GuardActor {
        private int count;
    
        void add1(Reply<Void> _reply) {
            start(false);
            count += 1;
            finish(false);
            _reply.response(null);
        }
    }
</pre>
<p>
This approach has eliminated the potential race condition involving <strong>externalReply</strong>.
But note that calls from A.begin to B.add1 are now done under lock, though calls to Reply.response are not.
So there will be times when the instances of classes A and B will both be locked because of a call to A.begin.
The problem then with this approach is that locking order must be maintained or there is a prospect of a
deadlock occurring.
</p>
<p>
When actors selectively process messages, a lot of care needs to be taken to avoid deadlocks,
deadlocks often being a specter of large projects that are maintained and embellished over time.
This problem is often masked by automatic restarts when an actor hangs, but that may not always be the best approach.
</p>
<p>
But there is another problem with selective message processing. Consider if B.add1 instead performed some 
asynchronous I/O. An instance of class A would remain locked until it gets a response back, which may not be until
the I/O operation completes. Likewise, any other object which calls any method on that instance of A will also remain
locked until the I/O operation completes. Ouch!
</p>
<p>
Remember that selective message processing is used to prevent race conditions, in this case a race condition involving
variable <strong>externalReply</strong>. Solving this in application code can, in time, lead to enormous complexity.
But it almost seems like the solution is worse than the problem it addresses. So shouldn't we explore alternative approaches?
</p>
</body>
</html>
