<html>
<head>
<title>
Modelling Actors with Locks
</title>
</head>
<body>
<p>
<a href="https://github.com/laforge49/JActor2#readme">JActor2</a> &gt; <a href="../../index.html">Docs</a> &gt; <a href="../index.html">Tutorials</a> &gt; Modelling Actors
</p>
<h1>
Modelling Actors with Locks
</h1>
<p>
It appears that too many developers do not understand actors, and that actors have not been explained very well.
My thought is that a model that behaves, to a degree, like actors might go a long way to explaining actors through analogy,
especially if that model can be implemented with a minimum of code. Mind, the model is only an approximation.
But even so, you may find it interesting/informative.
</p>
<h2>
A Sample Application
</h2>
<p>
We will start with a moderately simple, single-threaded, example:
</p>
<pre>
    public class BankAccount {
        private int balance;
        private int hold;
        private boolean closed;

        public boolean deposit(int amount) {
            if (closed)
                return false;
            balance += amount;
            return true;
        }

        public boolean transfer(int amount, BankAccount toAccount) {
            if (amount > balance)
                return false;
            balance -= amount;
            hold += amount;
            boolean depositSuccessful = toAccount.deposit(amount);
            hold -= amount;
            if (!depositSuccessful)
                balance += amount;
            return depositSuccessful;
        }
    
        public void close() {
            closed = true;
        }

        public static void main(String[] args) throws Exception {
            BankAccount accountA = new BankAccount();
            BankAccount accountB = new BankAccount();
        
            boolean depositSuccessful = accountA.deposit(1000);
            if (depositSuccessful)
                System.out.println("deposit successful");
            else
                System.out.println("deposit failed");

            boolean transferSuccessful = accountA.transfer(500, accountB);
            if (transferSuccessful)
                System.out.println("transfer successful");
            else
                System.out.println("transfer failed");
        }
    }
</pre>
<p>
Transferring money between bank accounts is interesting because it involves updating two accounts. 
Easy enough as a single-threaded process, but difficult to achieve in a multi-threaded environment without
risking deadlocks.
</p>
<h2>
Asynchronous Methods
</h2>
<p>
Asynchronous methods will serve as models for the asynchronous message processing of actors.
But we will start by introducing callbacks for returning the results of a method call.
The Reply interface defines these callbacks:
</p>
<pre>
    interface Reply&lt;RESPONSE_TYPE> {
        void response(RESPONSE_TYPE _value);
    }
</pre>
<p>
Asynchronous methods will always have Reply as their last argument,
and the returned value is passed back to the caller by calling the response method,
though not always on the same thread. Here is what BankAccount example looks like now:
</p>
<pre>
    public class BankAccount1 {
        private int balance;
        private int hold;
        private boolean closed;

        public void deposit(int amount, Reply&lt;Boolean> depositCompletion) {
            if (closed) {
                depositCompletion.response(false);
                return;
            }
            balance += amount;
            depositCompletion.response(true);
        }

        public void transfer(final int amount, final BankAccount1 toAccount, final Reply&lt;Boolean> transferCompletion) {
            if (amount > balance)
                transferCompletion.response(false);
            else {
                balance -= amount;
                hold += amount;
                toAccount.deposit(amount, (Boolean depositSuccessful) -> {
                    hold -= amount;
                    if (!depositSuccessful)
                        balance += amount;
                    transferCompletion.response(depositSuccessful);
                });
            }
        }

        public static void main(String[] args) throws Exception {
            BankAccount1 accountA = new BankAccount1();
            BankAccount1 accountB = new BankAccount1();

            accountA.deposit(1000, (Boolean depositSuccessful) -> {
                if (depositSuccessful)
                    System.out.println("deposit successful");
                else
                    System.out.println("deposit failed");
                accountA.transfer(500, accountB, (Boolean transferSuccessful) -> {
                    if (transferSuccessful)
                        System.out.println("transfer successful");
                    else
                        System.out.println("transfer failed");
                });
            });
        }
    }
</pre>
<p>
OK, if you are not used to using lambdas, the code may look a bit strange.
But there is a more serious problem than its strangeness--the code is not thread-safe.
Lets fix that first.
</p>
<h2>
Micro-Locks
</h2>
<p>
Actors acheive thread safety by processing only one message at a time.
In our model, a method is the equivalent of a message. 
So an obvious answer is to use locks to prevent more than one message from
operating on the object's state at a time.
But we need to exercise some care here. For our code to be a valid model of
an actor, it is important that nothing be left locked when one method calls another.
The answer is to limit the scope of each lock:
</p>
<pre>
    public class BankAccount2 {
        private int balance;
        private int hold;
        private boolean closed;

        public void deposit(int amount, Reply&lt;Boolean> depositCompletion) {
            boolean depositValid;
            synchronized(this) {
                depositValid = !closed;
                if (depositValid)
                    balance += amount;
            }
            depositCompletion.response(depositValid);
        }

        public void transfer(final int amount, final BankAccount2 toAccount, final Reply&lt;Boolean> transferCompletion) {
                boolean transferValid = false;
                synchronized(this) {
                    if (amount &lt;= balance) {
                        balance -= amount;
                        hold += amount;
                        transferValid = true;
                    }
                }
                if (transferValid)
                    toAccount.deposit(amount, (Boolean depositSuccessful) -> {
                        synchronized(BankAccount2.this) {
                            hold -= amount;
                            if (!depositSuccessful)
                                balance += amount;
                        }
                        transferCompletion.response(depositSuccessful);
                    });
                else
                    transferCompletion.response(false);
        }

        public static void main(String[] args) throws Exception {
            BankAccount2 accountA = new BankAccount2();
            BankAccount2 accountB = new BankAccount2();
        
            accountA.deposit(1000, (Boolean depositSuccessful) -> {
                if (depositSuccessful)
                    System.out.println("deposit successful");
                else
                    System.out.println("deposit failed");
                accountA.transfer(500, accountB, (Boolean transferSuccessful) -> {
                    if (transferSuccessful)
                        System.out.println("transfer successful");
                    else
                        System.out.println("transfer failed");
                });
            });
        }
    }
</pre>
<p>
The bank account class is now thread-safe.
And because the scope of the locks is limited, there is no possibility of deadlock.
But beauty is in the eye of the beholder and if you are not used to dealing with callbacks and lambdas,
then the code may be a bit hard to follow.
The temptation is to get rid of those callbacks.
Actors do not use callbacks, so that must be the right way to go, eh?
</p>
<h2>
Modelling One-Way Messaging
</h2>
<p>
One-way messaging seems to be pretty much the rage these days. I mean, look at the success of node.js!
Though we should keep in mind that in node.js the application logic is single threaded.
So there may be issues specific to the use of one-way messages by actors which are not encountered when
using node.js.
</p>
<p>
Now because we are using Java methods to emulate actor messages, we need to have an interface for replies:
</p>
<pre>
    public interface Source {
        void depositCompletion(boolean success);
        void transferCompletion(boolean success);
    }
</pre>
<p>
The bank account class and the main method need different implementations of the Source interface,
so they are now separate classes:
</p>
<pre>
    public class Test3 implements Source {
        BankAccount3 accountA = new BankAccount3();
        BankAccount3 accountB = new BankAccount3();

        public static void main(String[] args) {
            Test3 test = new Test3();
            test.begin();
        }

        void begin() {
            accountA.deposit(1000, this);
        }

        @Override
        public void depositCompletion(boolean depositSuccessful) {
            if (depositSuccessful)
                System.out.println("deposit successful");
            else
                System.out.println("deposit failed");
            accountA.transfer(500, accountB, this);
        }
    
        @Override
        public void transferCompletion(boolean transferSuccessful) {
            if (transferSuccessful)
                System.out.println("transfer successful");
            else
                System.out.println("transfer failed");
        }
    }
    
    public class BankAccount3 implements Source {
        private int balance;
        private int hold;
        private boolean closed;
    
        private Source transferSource;
        private int transferAmount;

        public void deposit(int amount, Source source) {
            boolean depositValid;
            synchronized(this) {
                depositValid = !closed;
                if (depositValid)
                    balance += amount;
            }
            source.depositCompletion(depositValid);
        }

        public void transfer(int amount, BankAccount3 toAccount, Source source) {
            boolean transferValid = false;
            synchronized(this) {
                if (amount &lt;= balance) {
                    balance -= amount;
                    hold += amount;
                    transferValid = true;
                }
            }
            if (transferValid) {
                transferAmount = amount;
                transferSource = source;
                toAccount.deposit(amount, this);
            }
            else
                source.transferCompletion(false);
        }
    
        @Override
        public void depositCompletion(boolean depositSuccessful) {
            synchronized(this) {
                hold -= transferAmount;
                if (!depositSuccessful)
                    balance += transferAmount;
            }
            transferSource.transferCompletion(depositSuccessful);
        }
    
        @Override
        public void transferCompletion(boolean success) {
            throw new UnsupportedOperationException();
        }
    }
</pre>
<p>
OK, the code seems to be clearer and is behaving more like an actor.
But now we have a problem with the <strong>transferSource</strong> and
<strong>transferAmount</strong> variables not being thread safe.
The problem arises when the transfer method is called before the previous call to that same method has completed.
</p>
<p>
Actually this is a fairly common problem encountered when using actors which receive messages from 
multiple sources. You can write application code to manage it, but it quickly becomes a combinatorics
problem that easily leads to an explosion of complexity, as explained by Ulf Wiger in his video
<a href="http://www.infoq.com/presentations/Death-by-Accidental-Complexity">Death by Accidental Complexity</a>.
</p>
<h2>
Selected Message Processing
</h2>
<p>
Most application frameworks support selected message processing, which eliminates the problem of multiple possible
message orderings when messages are being received from multiple sources. This is a bit of a challenge to implement 
when we are modelling messages with method calls, so we are going to need a base class to handle it for us.
Fortunately, for this example we only have two states: (1) when we are expecting a response and need to ignore new 
requests and (2) when we are not expecting any response and are ready to process any new requests.
</p>
<pre>
    import java.util.concurrent.atomic.AtomicBoolean;

    class GuardActor {
        private AtomicBoolean busy = new AtomicBoolean();
        private volatile boolean replyExpected;
    
        protected void lock(boolean isReply) {
            while (true) {
                while ((replyExpected && !isReply) || !busy.compareAndSet(false, true))
                    Thread.yield();
                if (!replyExpected && isReply) {
                    busy.set(false);
                    throw new UnsupportedOperationException("Reply received when none expected");
                }
                if (replyExpected == isReply)
                    return;
                busy.set(false);
                Thread.yield();
            }
        }
    
        protected void unlock(boolean expectingReply) {
            replyExpected = expectingReply;
            busy.set(false);
        }
    }
</pre>
<p>
Now we can replace the synchronization locks with calls to lock and unlock.
The lock and unlock methods take one argument, used to indicate when we are ready to process a response
to a request that was sent to another actor.
</p>
<pre>
    public class BankAccount4 extends GuardActor implements Source {
        private int balance;
        private int hold;
        private boolean closed;
    
        private Source transferSource;
        private int transferAmount;

        public void deposit(int amount, Source source) {
            boolean depositValid;
            lock(false);
            depositValid = !closed;
            if (depositValid)
                balance += amount;
            unlock(false);
            source.depositCompletion(depositValid);
        }

        public void transfer(int amount, BankAccount4 toAccount, Source source) {
            boolean transferValid = false;
            lock(false);
            if (amount &lt;= balance) {
                balance -= amount;
                hold += amount;
                transferValid = true;
            }
            if (transferValid) {
                transferAmount = amount;
                transferSource = source;
                unlock(true);
                toAccount.deposit(amount, this);
            } else {
                unlock(false);
                source.transferCompletion(false);
            }
        }
    
        @Override
        public void depositCompletion(boolean depositSuccessful) {
            lock(true);
            hold -= transferAmount;
            if (!depositSuccessful)
                balance += transferAmount;
            unlock(false);
            transferSource.transferCompletion(depositSuccessful);
        }
    
        @Override
        public void transferCompletion(boolean success) {
            throw new UnsupportedOperationException();
        }
    }
</pre>
<p>
Remember when looking at this code that we are only modelling an actor.
And most of the code that you see is not needed when using an language that
supports actors. So the actual application code is really short and sweet.
</p>
<p>
The code no longer has any race conditions, but now we have a new problem.
There is a potential for two actors to block (a deadlock of sorts) when 
both actors are transferring money to the other at just the right time.
But this is not a real deadlock, as no threads are blocked, at least when 
passing messages rather than modelling messages with method calls. This is
because actors use light-weight threads for message processing. 
So the only thing that happens is that the actors stop working.
</p>
<p>
Because of selected message processing, it is not unusual for actors to stop working.
So it is recommended practice to monitor actors and restart them as needed.
This means that sometimes a message will be lost, and applications need to handle
lost messages. So again, it is recommended practice to use timers to detect and
resend lost messages.
</p>
<p>
The result is that production code has a bit of defensive logic. But mostly things
work fine.
</p>
<h2>
Conclusion
</h2>
<p>
If at this point you are thinking that I do not like actors, you would be wrong.
They are a brilliant alternative to threads & locks. Only, I see a real need for
actors to support two-way messages instead of selective message processing.
Which is why I developed JActor2, along with some good friends.
</p>
You can find the JActor2 version of bank account 
<a href="http://www.agilewiki.org/docs/tutorials/core/bankAccount.html">here</a>.
</body>
</html>
