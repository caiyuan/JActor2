<html>
<head>
<title>
Modelling Actors with Locks
</title>
</head>
<body>
<p>
<a href="https://github.com/laforge49/JActor2#readme">JActor2</a> &gt; <a href="../../index.html">Docs</a> &gt; <a href="../index.html">Tutorials</a> &gt; Modelling Actors
</p>
<p>
It appears that too many developers do not understand actors, and that actors have not been explained very well.
My thought is that a model that behaves, to a degree, like actors might go a long way to explaining actors through analogy,
especially if that model can be implemented with a minimum of code. Mind, the model is only an approximation.
But even so, you may find it interesting/informative.
</p>
<h2>
A Sample Application
</h2>
<p>
We will start with a moderately simple, single-threaded, example:
</p>
<pre>
    public class BankAccount {
        private int balance;
        private int hold;
        private boolean closed;

        public boolean deposit(int amount) {
            if (closed)
                return false;
            balance += amount;
            return true;
        }

        public boolean transfer(int amount, BankAccount toAccount) {
            if (amount > balance)
                return false;
            balance -= amount;
            hold += amount;
            boolean depositSuccessful = toAccount.deposit(amount);
            hold -= amount;
            if (!depositSuccessful)
                balance += amount;
            return depositSuccessful;
        }
    
        public void close() {
            closed = true;
        }

        public static void main(String[] args) throws Exception {
            BankAccount accountA = new BankAccount();
            BankAccount accountB = new BankAccount();
        
            boolean depositSuccessful = accountA.deposit(1000);
            if (depositSuccessful)
                System.out.println("deposit successful");
            else
                System.out.println("deposit failed");

            boolean transferSuccessful = accountA.transfer(500, accountB);
            if (transferSuccessful)
                System.out.println("transfer successful");
            else
                System.out.println("transfer failed");
        }
    }
</pre>
<p>
Transferring money between bank accounts is interesting because it involves updating two accounts. 
Easy enough as a single-threaded process, but difficult to achieve in a multi-threaded environment without
risking deadlocks.
</p>
<h2>
Asynchronous Methods
</h2>
<p>
Asynchronous methods will serve as models for the asynchronous message processing of actors.
But we will start by introducing callbacks for returning the results of a method call.
The Reply interface defines these callbacks:
</p>
<pre>
    interface Reply<RESPONSE_TYPE> {
        void response(RESPONSE_TYPE _value);
    }
</pre>
<p>
Asynchronous methods will always have Reply as their last argument,
and the returned value is passed back to the caller by calling the response method,
though not always on the same thread. Here is what BankAccount example looks like now:
</p>
<pre>
    public class BankAccount1 {
        private int balance;
        private int hold;
        private boolean closed;

        public void deposit(int amount, Reply<Boolean> depositCompletion) {
            if (closed) {
                depositCompletion.response(false);
                return;
            }
            balance += amount;
            depositCompletion.response(true);
        }

        public void transfer(final int amount, final BankAccount1 toAccount, final Reply<Boolean> transferCompletion) {
                Reply<Boolean> onDeposit = new Reply<Boolean>() {
                    @Override
                    public void response(Boolean depositSuccessful) {
                        hold -= amount;
                        if (!depositSuccessful)
                            balance += amount;
                        transferCompletion.response(depositSuccessful);
                    }
                };

                if (amount > balance)
                    transferCompletion.response(false);
                else {
                    balance -= amount;
                    hold += amount;
                    toAccount.deposit(amount, onDeposit);
                }
        }

        public static void main(String[] args) throws Exception {
            BankAccount1 accountA = new BankAccount1();
            BankAccount1 accountB = new BankAccount1();

            Reply<Boolean> onDeposit = new Reply<Boolean>() {
                @Override
                public void response(Boolean depositSuccessful) {
                    Reply<Boolean> onTransfer = new Reply<Boolean>() {
                        @Override
                        public void response(Boolean transferSuccessful) {
                            if (transferSuccessful)
                                System.out.println("transfer successful");
                            else
                                System.out.println("transfer failed");
                        }
                    };
                
                    if (depositSuccessful)
                        System.out.println("deposit successful");
                    else
                        System.out.println("deposit failed");
                    accountA.transfer(500, accountB, onTransfer);
                };
            };
        
            accountA.deposit(1000, onDeposit);
        }
    }
</pre>
<p>
OK, it is ugly. That's what happens when you use callbacks.
But there is a more serious problem than its ugliness--the code is not thread-safe.
Lets fix that first.
</p>
<h2>
Micro-Locks
</h2>
<p>
Actors acheive thread safety by processing only one message at a time.
In our model, a method is the equivalent of a message. 
So an obvious answer is to use locks to prevent more than one message from
operating on the object's state at a time.
But we need to exercise some care here. For our code to be a valid model of
an actor, it is important that nothing be left locked when one method calls another.
The answer is to limit the scope of each lock:
</p>
<pre>
    public class BankAccount2 {
        private int balance;
        private int hold;
        private boolean closed;

        public void deposit(int amount, Reply<Boolean> depositCompletion) {
            boolean depositValid;
            synchronized(this) {
                depositValid = !closed;
                if (depositValid)
                    balance += amount;
            }
            depositCompletion.response(depositValid);
        }

        public void transfer(final int amount, final BankAccount2 toAccount, final Reply<Boolean> transferCompletion) {
                Reply<Boolean> onDeposit = new Reply<Boolean>() {
                    @Override
                    public void response(Boolean depositSuccessful) {
                        synchronized(BankAccount2.this) {
                            hold -= amount;
                            if (!depositSuccessful)
                                balance += amount;
                        }
                        transferCompletion.response(depositSuccessful);
                    }
                };

                boolean transferValid = false;
                synchronized(this) {
                    if (amount <= balance) {
                        balance -= amount;
                        hold += amount;
                        transferValid = true;
                    }
                }
                if (transferValid)
                    toAccount.deposit(amount, onDeposit);
                else
                    transferCompletion.response(false);
        }

        public static void main(String[] args) throws Exception {
            BankAccount2 accountA = new BankAccount2();
            BankAccount2 accountB = new BankAccount2();
        
            Reply<Boolean> onDeposit = new Reply<Boolean>() {
                @Override
                public void response(Boolean depositSuccessful) {
                    Reply<Boolean> onTransfer = new Reply<Boolean>() {
                        @Override
                        public void response(Boolean transferSuccessful) {
                            if (transferSuccessful)
                                System.out.println("transfer successful");
                            else
                                System.out.println("transfer failed");
                        }
                    };
                
                    if (depositSuccessful)
                        System.out.println("deposit successful");
                    else
                        System.out.println("deposit failed");
                    accountA.transfer(500, accountB, onTransfer);
                };
            };
        
            accountA.deposit(1000, onDeposit);
        }
    }
</pre>
<p>
The bank account class is now thread-safe.
And because the scope of the locks is limited, there is no possibility of deadlock.
But beauty is in the eye of the beholder and if you are not used to dealing with callbacks,
then the code is not only ugly but hard to understand.
The temptation is to get rid of those callbacks.
Actors do not use callbacks, so that must be the right way to go, eh?
</p>
<h2>
Modelling One-Way Messaging
</h2>
<p>
One-way messaging seems to be pretty much the rage these days. I mean, look at the success of node.js!
Though we should keep in mind that in node.js the application logic is single threaded.
So there may be issues specific to the use of one-way messages by actors which are not encountered when
using node.js.
</p>
<p>
Now because we are using Java methods to emulate actor messages, we need to have an interface for replies:
</p>
<pre>
    public interface Source {
        void depositCompletion(boolean success);
        void transferCompletion(boolean success);
    }
</pre>
<p>
The bank account class and the main method need different implementations of the Source interface,
so they are now separate classes:
</p>
<pre>
    public class Test3 implements Source {
        BankAccount3 accountA = new BankAccount3();
        BankAccount3 accountB = new BankAccount3();

        public static void main(String[] args) {
            Test3 test = new Test3();
            test.begin();
        }

        void begin() {
            accountA.deposit(1000, this);
        }

        @Override
        public void depositCompletion(boolean depositSuccessful) {
            if (depositSuccessful)
                System.out.println("deposit successful");
            else
                System.out.println("deposit failed");
            accountA.transfer(500, accountB, this);
        }
    
        @Override
        public void transferCompletion(boolean transferSuccessful) {
            if (transferSuccessful)
                System.out.println("transfer successful");
            else
                System.out.println("transfer failed");
        }
    }
    
    public class BankAccount3 implements Source {
        private int balance;
        private int hold;
        private boolean closed;
    
        private Source transferSource;
        private int transferAmount;

        public void deposit(int amount, Source source) {
            boolean depositValid;
            synchronized(this) {
                depositValid = !closed;
                if (depositValid)
                    balance += amount;
            }
            source.depositCompletion(depositValid);
        }

        public void transfer(int amount, BankAccount3 toAccount, Source source) {
            boolean transferValid = false;
            synchronized(this) {
                if (amount <= balance) {
                    balance -= amount;
                    hold += amount;
                    transferValid = true;
                }
            }
            if (transferValid) {
                transferAmount = amount;
                transferSource = source;
                toAccount.deposit(amount, this);
            }
            else
                source.transferCompletion(false);
        }
    
        @Override
        public void depositCompletion(boolean depositSuccessful) {
            synchronized(this) {
                hold -= transferAmount;
                if (!depositSuccessful)
                    balance += transferAmount;
            }
            transferSource.transferCompletion(depositSuccessful);
        }
    
        @Override
        public void transferCompletion(boolean success) {
            throw new UnsupportedOperationException();
        }
    }
</pre>
<p>
OK, the code seems to be clearer and is behaving more like an actor.
But now we have a problem with the <strong>transferSource</strong> and
<strong>transferAmount</strong> variables not being thread safe.
The problem arises when the transfer method is called before the previous call to that same method has completed.
</p>
</body>
</html>
